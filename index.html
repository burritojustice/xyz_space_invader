<!doctype html>
<html lang="en-us">
<head>
	<meta charset="utf-8">
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
	<title>HERE XYZ Space Invader</title>
	<link href="space-invader-144-294760.png" rel="icon" type="image/x-icon" />
	<link rel="stylesheet" href="https://unpkg.com/leaflet@1.3.3/dist/leaflet.css" />
	
	<style>
	html, body {
		margin: 0;
		border: 0;
		font-family: 'Fira Sans', sans-serif;
		font-size: 12px;
		}
		
	#map {
	    height: 100%;
	    width: 100%;
		position: absolute; 
	}

	#label {
		text-align: center;
		top: 0%;
		height: 20%;
		width: 40%;
		left: 30%;
		position: absolute;
		margin: 0 auto;
		z-index: 1000;
		opacity: 0.8;
		background-color: white;
		font: 18px 'Fira Sans', sans-serif;
		text-shadow: 2px 2px #FFFFFF;
		display: table;
		padding: 10px;
		border-radius: 15px; 
	}
	#text{
/*             display: table-cell; */
		vertical-align: middle;
		text-align: center;
	}
	#small{
		font-size:12px;
	}
	#controls {
		position: absolute;
/*             left: 1em; */
/*             top: 25px; */
		z-index: 1000;
/*             background-color: rgba(200, 200, 200, 0.75); */
		/* display: none; */
		width: 300px;
		height: 100%;
/*             border-radius: 6px; */
	}
	
	#properties {
/* 		height: auto; */
		overflow: scroll;
		height: 40vh;

	}
	
	#colors {
/* 		height: auto; */
		overflow: scroll;
/* 		height: 1vh; */
		max-height: 40vh;

	}

	#controls div {
		margin: 10px;
		padding: 0.5em;
		background-color: rgba(200, 200, 200, 0.75);
		border: 1px solid black;
		border-radius: 3px;
		color: black;
		box-shadow: 2px 2px 2px black;
		max-height: 900px;
		overflow: scroll;
	}
	
	#minidiv {
		margin: 1px;
		padding: 0.5em;
		color: black;
	}
	
	#controls_right {
		position: absolute;
		z-index: 1000;
/*             width: 150px; */
		width: 350px;
		height: 85%;
		right: 0%
	}
	#controls_right div {
		margin: 10px;
		padding: 0.5em;
		background-color: rgba(200, 200, 200, 0.75);
		border: 1px solid black;
		border-radius: 3px;
		color: black;
		box-shadow: 2px 2px 2px black;
		max-height: 500px;
		overflow: scroll;
	}
	
	#controls_middle {
		position: absolute;
		z-index: 1000;
/*             width: 150px; */
		width: 50%
		height: 85%;
		left: 20%
	}
	
	#controls_middle div {
		margin: 10px;
		padding: 0.5em;
		background-color: rgba(200, 200, 200, 0.75);
		border: 1px solid black;
		border-radius: 3px;
		color: black;
		box-shadow: 2px 2px 2px black;
		max-height: 900px;
		overflow: scroll;
	}
	.dot {
		height: 11px;
		width: 11px;
		background-color: yellow;
		border: 2px solid grey;
		border-radius: 50%;
		display: inline-block;
		vertical-align:bottom; 
/* 		float:right; */
	}
		
	</style>
</head>
<body>
<div id="map">
</div>

<div id="controls">
	<div id="spaces">
		<p id="space_info"></p>
		<p id="style_info"></p>
<!-- 	<select id="spaceSelect"></select> -->
	</div>
	<div id="properties">Interact with map to see properties.<br>Click on a property value to generate unique colors. </div>

	<div id="colors">
		<p id="colorProperties">click on property value for unique colors</p>
		<table id="prop_stats"></table>
		<p style="color:blue;" id="clear_color_properties" onclick="clearColorProperties()">CLEAR COLOR FILTERS</p>	
	</div>
</div>
<div id="controls_middle">
	<div id="tableLabel">
		<table id="spaceTable">
		    <tbody id="spaceTablebody"></tbody>
		</table>
	</div>
</div>
<div id="controls_right">
	<div id="tag_summary">
		<table id="tag_stats"></table>
		<p id="tags_filtered"><i>no tags filtered<br><br></i></p>
		<p style="color:blue;" id="clear_filters" onclick="clearTags()">CLEAR TAG FILTERS</p>
		<p id="and_or">
			<input type="radio" name="and_or" value="or" checked onclick="toggleOr()">or
  			<input type="radio" name="and_or" value="and" onclick="toggleAnd()">and<br>
		<p>
	</div>
	<div id="tags_list">
		<p id="someTagsallTags" onclick="showAllKnownTags">tags visible in viewport</p>
		<table><tr>
		<td style="color:blue;" id="at_filter" onclick="filterAts()">[only show @ tags]</td>
		<td style="color:blue;" id="alphabetize" onclick="alphabetize_tags()">[sort by name]</td>
		</tr></table>
		<p id="tags"></p>
	</div>
</div>


<!-- 
<div id="label" style="text-align: center; color: red">
	<p id="text">Space ID
	</p>
</div>
 -->
<script src="https://unpkg.com/leaflet@1.3.3/dist/leaflet.js">
</script>
<!-- Main tangram library -->
<script src="https://unpkg.com/tangram/dist/tangram.min.js">
</script>
<script src="/leaflet-hash.js">
</script>
<script>

	var property_text
//	var space_count, space_size
	var tagSet = new Set() // all the tags seen so far
	var tagsViewport = []//  unique lists of tags on screen
	var propsSet = new Set()
	var propsViewport = []
	var color_by_prop = false
	var query, space, token, tags;
	var and_or = 'or'
	var filterAt = false // toggle for only showing tags with an @
	var alphabetize = false // list tags by name, not frequency
	var tags_filtered = [] // tags in use
	// keyboard toggles
	var randomColors = 0,highlight = 0,lines = 0,water = 0,outlines = 1,points = 0,bright = 0,basemap = 0
	var roads = 1, buildings = 1
	var property
	
	var tag_list = []
	var space_list = {}
	var layer
	var scene_file = 'tangram_xyz_scene.yaml'
	var map, hash, popup
	
	map = L.map('map', {boxZoom: false});
    hash = new L.Hash(map);
    popup = L.popup();
	//map.setView([37.7,-122.4], 12);
	map.zoomControl.setPosition('bottomright')
	
	
	query = parseQuery(window.location.search.slice(1));
	
	// grab query parameters from the url and assign them to globals
	
	if (query.space){
		space = query.space
	}
	if (query.token){
		token = query.token
	}
	if (query.tags){
		tags = query.tags
		console.log(tags)
		tags_filtered.push(tags)
		document.getElementById("tags_filtered").innerHTML = "filtering by tags:<br>" + tags
	}
	
	if (!query.space || !query.token){
		console.log('no token or space')
		scene_file = 'dark_refill.yaml'
		map.setView([37.7,-122.4], 2);
// 		map = L.map('map', {boxZoom: false});
//     	hash = new L.Hash(map);
//     	popup = L.popup();
// 		map.zoomControl.setPosition('bottomright')

		
		inputSpace() // get user to enter a space id and token
		
	}
	
	if (query.buildings){
		buildings = query.buildings
	}	
	if (query.randomColors){
		randomColors = query.randomColors
	}		
	if (query.highlight){
		highlight = query.highlight
	}
	if (query.bright){
		bright = query.bright
	}
	if (query.outlines){
		outlines = query.outlines
	}
	if (query.points){
		points = query.points
	}
	if (query.roads){
		roads = query.roads
	}
	if (query.lines){
		lines = query.lines
	}
	if (query.water){
		water = query.water
	}
	if (query.basemap){
		basemap = query.basemap
	}
	if (query.property){
		property = query.property
	}	
	if (query.tags){
		// look for AND tags
		if (query.tags.includes('+')){
			tags_filtered = query.tags.split('+')
			and_or = 'and'
		}
		// look for OR tags
		if (query.tags.includes(',')){
			tags_filtered = query.tags.split(',')
			and_or = 'or'
		}		
	}
	
	console.log('url query is',query)
	
	
 	var url_hash = window.location.hash.slice(1, window.location.hash.length).split('/');
	var map_start_location = null
	if (url_hash.length == 3) {
		map_start_location = {
			lat: Number(url_hash[1]),
			lng: Number(url_hash[2]),
			zoom: Number(url_hash[0])
		};
	}
	
    makeLayer()
    
// 	getBbox(space,token)
	
	if (map_start_location == null){
		console.log('no url hash, getting bbox')
		getBbox(space,token)
	} else {
		console.log('using url hash', map_start_location)
		map.setView([map_start_location.lat,map_start_location.lng],map_start_location.zoom)
		getStats(space,token)
	}
	
// 	layer.scene.subscribe({
//     	load: getSpace
//     	}
// 	);

	layer.scene.subscribe({
    	load: function(){
    		getSpace()
//     		queryViewport()
            applyURLQuery()
    	}
	});
	

	map.on("keypress", function(e) {
		// b = toggle buildings
		// c = toggle colors (color hash of all properties, pretty good but some chance of bordering features getting a similar color)
		// h = toggle lines and dot highlights
		// l = colors good for a light basemap
		// o = toggle polygon outlines
		// p = make dots bigger
		// r = toggle roads
		// s = make dots smaller and lines narrower
		// w = put polygons under water
	
    	var keyPressed = e.originalEvent.key;
    	
		
    	if (keyPressed == "b") { // toggle buildings
    		toggleBuildings()
		}	
    	
    	if (keyPressed == "c") { // color hash each feature
			toggleColors() 
		}
		
    	if (keyPressed == "h") { // highlight colors and make points bigger
			toggleHighlight()
		}
		
    	if (keyPressed == "a") { // pick colors for a light basemap
			toggleBright()
		}

    	if (keyPressed == "m") { // toggle basemap
    		updateBasemap()
    	}		

    	if (keyPressed == "o") { // toggle polygon outlines
			toggleOutlines()
		}	
		
    	if (keyPressed == "p") { // make points bigger
			togglePoints()
		}	
		
//     	if (keyPressed == "q") {
//     		layer.scene.queryFeatures({ filter: { $source: '_xyzspace' }}).then(
//     			features => {console.log(features)
//     			console.log('yo')
//     		});
//     		queryViewport()
// 		}			
		
    	if (keyPressed == "r") { // toggle roads
			toggleRoads()
		}	
		
    	if (keyPressed == "l") { // make lines smaller
			toggleLines()
		}

    	if (keyPressed == "w") { // put polygons under water
    		toggleWater()
		}	

		makeQuery(query)

	});
 
 
	map.on("moveend", function(){
		queryViewport()
		if (query.property){
			colorProperties(query.property)
		}
	})
	map.on("zoomend", function(){
		queryViewport()
		if (query.property){
			colorProperties(query.property)
		}
	})
// 	map.on("load", queryViewport)
	map.on("load", function(){
		queryViewport()
		applyURLQuery()
	})

// 	map.on('tangramloaded', function(e) { //ugh mapzen.js only 
// 		queryViewport()
//         applyURLQuery()
//         
//       });
	
	// this is to apply any arguments from the URL query. some of these conflict (bright and highlight with property-driven colors, and point sizes, need to figure that out)
	
	function applyURLQuery(){
		console.log('applying url query',query)
		if (query.basemap == 1){basemapDots()}
		if (query.basemap == 2){basemapPixel()}
		if (query.basemap == 3){basemapWalkabout()}
		if (query.basemap == 4){basemapRefill()}
		
		
		if (query.buildings == 0){disableBuildings()}
		
		if (query.colors == 1){enableColorHash()}
		
		if (query.highlight == 1){enableHighlight()}
		
		if (query.bright == 1){enableBright()}
		
		if (query.outlines == 1){enableOutlines()}
		if (query.outlines == 0){disableOutlines()}

		
		if (query.points == 1){mediumPoints()}
		if (query.points == 2){bigPoints()}
		if (query.points == 3){smallerPoints()}
		if (query.points == 4){smallPoints()}
		
		if (query.roads == 0){disableRoads()}
		
		if (query.lines == 1){enableSmallerLines()}
		if (query.lines == 2){enableMuchSmallerLines()}

		if (query.water == 0){underWater()}
		
		if (query.property){
			console.log('we have a property and it is',query.property)
			colorProperties(query.property)
		}
		displayQuery()
		
	}
	
	function displayQuery(){
		document.getElementById("style_info").innerHTML = ''
		var query_string = Object.entries(query)
		var row_1 = "<tr><td onclick='toggleRoads()'>roads:</td><td>" + query.roads + "</td><td onclick='toggleBuildings()'>buildings:</td><td>" + query.buildings + "</td><td onclick='toggleWater()'>water:</td><td>" + query.water + "</td></tr>" 
		var row_2 = "</td><td onclick='togglePoints()'>points:</td><td>" + query.points + "</td><td onclick='toggleLines()'>lines:</td><td>" + query.lines + "</td><td onclick='toggleOutlines()'>outlines:</td><td>" + query.outlines + "</td></tr>" 
		var row_3 = "<tr><td onclick='updateBasemap()'>basemap:</td><td>" + query.basemap + "</td><td onclick='toggleColors()'>colors:</td><td >" + query.randomColors + "</td></tr>" 
		var query_table = "<table>" + row_1 + row_2 + row_3 + "</table>"
		console.log(query_table)
		document.getElementById("style_info").innerHTML = query_table

	}
	
	function toggleBuildings(){
		// toggle buildings
		if (buildings == 1){ // turn off buildings
			disableBuildings()
		}
		else{ // turn on buildings
			enableBuildings()
		}
		query.buildings = buildings //
		makeQuery(query)

onclick='toggleColors()'	}
	function disableBuildings(){
		layer.scene.config.layers.buildings.enabled = false
		layer.scene.updateConfig()
		buildings = 0
		console.log('no buildings')	
	}
	function enableBuildings(){
		layer.scene.config.layers.buildings.enabled = true
		layer.scene.updateConfig()
		buildings = 1
		console.log('yes buildings')
	}
	

	
	
	function toggleColors(){
		// toggle random colors for features
		if (randomColors == 0){ // make random colors
 			enableColorHash()
		} 
		else{ // revert to default colors
			disableColorHash()
		}
		query.randomColors = randomColors
		makeQuery(query)

	}
	function enableColorHash(){
		layer.scene.config.layers._xyz_polygons.draw._polygons_inlay.color = 'global.color_hash'
		layer.scene.config.layers._xyz_lines.draw._lines.color = 'global.color_hash'
		layer.scene.config.layers._xyz_dots.draw.points.color = 'global.color_hash'

		console.log('color feature hash')
		layer.scene.updateConfig();	
		randomColors = 1 
	}
	function disableColorHash(){
		layer.scene.config.layers._xyz_polygons.draw._polygons_inlay.color = 'global.color_polygons'
		layer.scene.config.layers._xyz_lines.draw._lines.color = 'global.color_lines'
		layer.scene.config.layers._xyz_dots.draw.points.color = 'global.color_points'
		console.log('base colors')
		layer.scene.updateConfig();	
		randomColors = 0
	}	
	
	
	
	function toggleHighlight(){
		// highlight colors, make things bigger and wider
		if (highlight == 0){
			enableHighlight()
		}
		else{
			disableHiglight()
		}
		query.highlight = highlight
	}
	function enableHighlight(){ // outline points, make points bigger, thicker lines
		layer.scene.config.layers._xyz_lines.draw._lines.outline = 'global.highlight'
		layer.scene.config.layers._xyz_dots.draw.points.size = '12px'
		layer.scene.config.layers._xyz_polygons._outlines.draw._lines.width = '3px'
		layer.scene.updateConfig()
		highlight = 1
		console.log('big')
	}
	function disableHighlight(){
		layer.scene.config.layers._xyz_lines.draw._lines.outline = null
		layer.scene.config.layers._xyz_dots.draw.points.size = '6px'
		layer.scene.config.layers._xyz_polygons._outlines.draw._lines.width = '1px'
		layer.scene.updateConfig()
		highlight = 0
		console.log('not big')
	}	
		
		
	function toggleBright(){
	// make colors that are nicer on a light basemap
		if (bright == 0){ 
			enableBright()
		}
		else{
			disableBright()
		}
		query.bright = bright
	}
	function enableBright(){
		layer.scene.config.layers._xyz_lines.draw._lines.color = [1,0,0,0.5]
		layer.scene.config.layers._xyz_dots.draw.points.color = [0,0,1,0.5]
		layer.scene.updateConfig()
		bright = 1
		console.log('light basemap friendly')
	}
	function disableBright(){
		layer.scene.config.layers._xyz_lines.draw._lines.color = 'global.color_lines'
		layer.scene.config.layers._xyz_dots.draw.points.color = 'global.color_points'
		layer.scene.updateConfig()
		bright = 0
		console.log('dark basemap friendly')
	}
	
	
	function toggleOutlines(){
	// change outlines of polygons
		if (outlines == 0){
			enableOutlines()
		}
		else if (outlines == 1){
			disableOutlines()
		}
		query.outlines = outlines
		makeQuery(query)

	}
	function disableOutlines(){
		layer.scene.config.layers._xyz_polygons._outlines.draw._lines.width = '0px'
		layer.scene.updateConfig()
		outlines = 0
		console.log('no polygon outlines')
	}
	function enableOutlines(){
		layer.scene.config.layers._xyz_polygons._outlines.draw._lines.width = '1px'
		layer.scene.updateConfig()
		outlines = 1
		console.log('yes polygon outlines')
	}
	
	function enableOutlinesNoFill(){
		layer.scene.config.layers._xyz_polygons.draw._polygons_inlay.color = null
		var color
		if (property){
			layer.scene.config.layers._xyz_polygons._outlines.draw._lines.color = colorProperties(property)
			console.log('outlines only, colored by property')

		}
		if (randomColors = 1){
			layer.scene.config.layers._xyz_polygons._outlines.draw._lines.color = 'global.color_hash'
			console.log('outlines only, colored randomly')

		}
		layer.scene.updateConfig()
		outlines = 2
	}
	

	
	function togglePoints(x){
		// make points big, bigger, biggest,smaller
		if (points == 0){
			mediumPoints()
		}
		else if (points == 1){
			bigPoints()
		}
		else if (points == 2){
			smallerPoints()
		}
		else if (points == 3){
			smallPoints()
		}
		query.points = points
		makeQuery(query)

	}
	function mediumPoints(){
		layer.scene.config.layers._xyz_dots.draw.points.size = '12px'
// 				layer.scene.config.layers._xyz_dots.draw.points.color = [1,0,0,0.5]
		layer.scene.config.layers._xyz_dots.draw.points.outline.color = [1,1,1,0.5]
		layer.scene.config.layers._xyz_dots.draw.points.outline.width = '1px'
		layer.scene.updateConfig()
		points = 1
		console.log('medium points')
	}
	function bigPoints(){
		layer.scene.config.layers._xyz_dots.draw.points.size = '16px'
// 				layer.scene.config.layers._xyz_dots.draw.points.color = [1,0,0,0.5]
		layer.scene.config.layers._xyz_dots.draw.points.outline.color = [1,1,1,0.5]
		layer.scene.config.layers._xyz_dots.draw.points.outline.width = '1px'
		layer.scene.updateConfig()
		points = 2
		console.log('big points')
	}
	function smallerPoints(){
		layer.scene.config.layers._xyz_dots.draw.points.size = '3px'
// 				layer.scene.config.layers._xyz_dots.draw.points.color = 'global.color_points'
		layer.scene.config.layers._xyz_dots.draw.points.outline.color = null
		layer.scene.config.layers._xyz_dots.draw.points.outline.width = null
		layer.scene.updateConfig()
		points = 3
		console.log('smaller points')
	}
	function smallPoints(){
		layer.scene.config.layers._xyz_dots.draw.points.size = '6px'
// 				layer.scene.config.layers._xyz_dots.draw.points.color = 'global.color_points'
		layer.scene.config.layers._xyz_dots.draw.points.outline.color = null
		layer.scene.config.layers._xyz_dots.draw.points.outline.width = null
		layer.scene.updateConfig()
		points = 0
		console.log('small points')
	}
	
	
	function toggleRoads(){
		// toggle road visibilty
		if (roads == 1){
			disableRoads()
		}
		else{
			enableRoads()
		}
		query.roads = roads
		makeQuery(query)

	}
	function disableRoads(){
		layer.scene.config.layers.roads.enabled = false
		if (layer.scene.config.layers.pois){
			layer.scene.config.layers.pois.enabled = false //to handle exit numbers
		}
		layer.scene.updateConfig()
		roads = 0
		console.log('no roads')
	}
	function enableRoads(){
		layer.scene.config.layers.roads.enabled = true
		if (layer.scene.config.layers.pois){
			layer.scene.config.layers.pois.enabled = true
		}
		layer.scene.updateConfig()
		roads = 1
		console.log('yes roads')
	}
	
	// make lines smaller
	function toggleLines(x){
		if (lines == 0){
			enableSmallerLines()
		}
		else if (lines == 1) {
			enableMuchSmallerLines()
		}
		else if (lines == 2) {
			disableSmallerLines()
		}
		query.lines = lines
		makeQuery(query)

	}
	function enableSmallerLines(){
// 		layer.scene.config.layers._xyz_dots.draw.points.size = '3px'
		layer.scene.config.layers._xyz_lines.draw._lines.width = '2px'
		layer.scene.updateConfig()
		lines = 1
		console.log('smaller lines')
	}
	function enableMuchSmallerLines(){
// 		layer.scene.config.layers._xyz_dots.draw.points.size = '1px'
		layer.scene.config.layers._xyz_lines.draw._lines.width = '1px'
		layer.scene.updateConfig()
		lines = 2
		console.log('much smaller lines')
	}
	function disableSmallerLines(){
// 		layer.scene.config.layers._xyz_dots.draw.points.size = '6px'
		layer.scene.config.layers._xyz_lines.draw._lines.width = '4px'
		layer.scene.updateConfig()
		lines = 0
		console.log('regular lines')
	}
	
	
	
	function toggleWater(x){
		// move polygons above or below water
		
		if (water == 0){
			underWater()
		}
		else{
			overWater()
		}
		query.water = water
		makeQuery(query)

	
	}
	
	function underWater(){
		layer.scene.config.layers._xyz_polygons.draw._polygons_inlay.order = 200
		layer.scene.updateConfig()
		water = 1
		console.log('under water')
	}
	function overWater(){
		layer.scene.config.layers._xyz_polygons.draw._polygons_inlay.order = 300
		layer.scene.updateConfig()
		water = 0
		console.log('over water')
	}
	
	
	function updateBasemap(){
		
		// toggle basemap
		
		// this is overriding an import of the initial basemap, so we need to call tangram_xyz_scene_no_import.yaml which does not import a basemap -- this is a pain to keep in sync -- if you make a change to the yaml, you need to do it in both scene files

		console.log('m',basemap)

		if (basemap == 0){
			basemapDots()
		}
		else if (basemap == 1){
			basemapPixel()
		}
// 		else if (basemap == 2){
//			basemapStripes
// 		}
// 		else if (basemap == 3){
//			basemapGrid()
// 		}
		else if (basemap == 2){ // skipping stripes and grid for now, otherwise this would be 4
			basemapWalkabout()
		}
		else if (basemap == 5){
			basemapRefill()		
		}
		else if (basemap == 6){
			basemapNone()
		}
		else if (basemap == 7){ //reset to grey-gold refill
			basemapRefillDark()		
		}
		query.basemap = basemap
	}
	
	function basemapDots(){
		console.log('loading dots')
		layer.scene.load({    
			import: [
			  'https://raw.githubusercontent.com/sensescape/xyz-dots/master/scene.yaml',
			  'https://s3.amazonaws.com/xyz-demo/data/demo.yaml',
			  'tangram_xyz_scene_no_import.yaml'
			],
			layers: {
			  _xyz_lines: { draw: { _lines: { color: [1,0,0,0.5] } } },
			  _xyz_dots: { draw: { points: { color: [0,0,1,0.5] } } }
			},
			sources: {
				_xyzspace: {
					url_params: {
						tags: tags_filtered
					}
				}
			}
		})
		basemap = 1
		console.log('dots')
		drawTags()
	}
	
	function basemapPixel(){
		console.log('loading pixel')
		layer.scene.load({    
			import: [
			  'https://raw.githubusercontent.com/sensescape/xyz-pixel/master/scene.yaml',
			  'https://s3.amazonaws.com/xyz-demo/data/demo.yaml',
			  'tangram_xyz_scene_no_import.yaml'
			],
			layers: {
			  _xyz_lines: { draw: { _lines: { color: [1,0,0,0.5] } } },
			  _xyz_dots: { draw: { points: { color: [0,0,1,0.5] } } }
			},
			sources: {
				_xyzspace: {
					url_params: {
						tags: tags_filtered
					}
				}
			}
		})
		basemap = 2 
		console.log('pixel')
		drawTags()
	}
	
	function basemapStripes(){
		console.log('loading stripes')
		layer.scene.load({    
			import: [
			  'https://raw.githubusercontent.com/sensescape/xyz-stripes/master/scene.yaml',
			  'https://s3.amazonaws.com/xyz-demo/data/demo.yaml',
			  'tangram_xyz_scene_no_import.yaml'
			],
			layers: {
			  _xyz_lines: { draw: { _lines: { color: [1,0,0,0.5] } } },
			  _xyz_dots: { draw: { points: { color: [0,0,1,0.5] } } }
			},
			sources: {
				_xyzspace: {
					url_params: {
						tags: tags_filtered
					}
				}
			}
		})
		basemap = 3
		console.log('stripes')
		drawTags()
	}
	
	function basemapGrid(){
		console.log('loading grid')
		layer.scene.load({    
			import: [
			  'https://raw.githubusercontent.com/sensescape/xyz-grid/master/scene.yaml',
			  'https://s3.amazonaws.com/xyz-demo/data/demo.yaml',
			  'tangram_xyz_scene_no_import.yaml'
			],
			layers: {
			  _xyz_lines: { draw: { _lines: { color: [1,0,0,0.5] } } },
			  _xyz_dots: { draw: { points: { color: [0,0,1,0.5] } } }
			},
			sources: {
				_xyzspace: {
					url_params: {
						tags: tags_filtered
					}
				}
			}
		})
		basemap = 4
		console.log('grid')
		drawTags()
	}	
	
	function basemapWalkabout(){
		console.log('loading walkabout')
		layer.scene.load({
			import: [
				'https://www.nextzen.org/carto/walkabout-style/walkabout-style.zip',
				'https://s3.amazonaws.com/xyz-demo/data/demo.yaml',
				'tangram_xyz_scene_no_import.yaml'
			]
		})
		
		basemap = 5
		console.log('walkabout')
	}
	
	function basemapRefill(){
		layer.scene.load({
			import: [
				'https://www.nextzen.org/carto/refill-style/refill-style.zip',
				'https://www.nextzen.org/carto/refill-style/themes/label-4.zip',
				'https://www.nextzen.org/carto/refill-style/themes/terrain-shading-dark.zip',
				'https://s3.amazonaws.com/xyz-demo/data/demo.yaml',
				'tangram_xyz_scene_no_import.yaml'
			]
		})
		basemap = 6
		console.log('refill')	
	}
	
	function basemapNone(){
		layer.scene.load({
			import: [
				'https://s3.amazonaws.com/xyz-demo/data/demo.yaml',
				'tangram_xyz_scene_no_import.yaml'
			],
			scene: {
				background: { 
					color: [0,0,0]
				}
			}
		})

		basemap = 7
		console.log('no basemap')
		
		drawTags()	
	}
	
	function basemapRefillDark(){
		layer.scene.load({
			import: [
				'https://www.nextzen.org/carto/refill-style/refill-style.zip',
				'https://www.nextzen.org/carto/refill-style/themes/color-gray-gold.zip',
				'https://www.nextzen.org/carto/refill-style/themes/label-4.zip',
				'https://www.nextzen.org/carto/refill-style/themes/terrain-shading-dark.zip',
				'https://s3.amazonaws.com/xyz-demo/data/demo.yaml',
				'tangram_xyz_scene_no_import.yaml'
			]
		})
		layer.scene.config.layers._xyz_lines.draw._lines.color = 'global.color_lines'
		layer.scene.config.layers._xyz_dots.draw.points.color = 'global.color_points'
		layer.scene.updateConfig()
		basemap = 0
		console.log('grey-gold refill')		
	}
	
    function makeLayer(){
    // moved this to a function while trying to get inputSpace() -> getSpaces() to work
		layer = Tangram.leafletLayer({
//          scene: 'https://s3.amazonaws.com/xyz-demo/scenes/tangram_xyz_scene.yaml',
			scene: scene_file,
// 			scene: 'dark_refill.yaml',
			attribution: '<a href="https://github.com/tangrams/tangram" target="_blank">Tangram</a> | &copy; OSM contributors | <a href="https://explore.xyz.here.com/">HERE XYZ</a>',
			events: {
			  click: function(selection) {
				if (selection.feature) {
				  var properties = (selection.feature.properties)
				  console.log(selection.feature)
				  showPopup(selection.leaflet_event.latlng, properties);
				} else {
				  map.closePopup();
				  console.log("close")
				}
			  },
			  hover: function(selection) {
				if (selection.feature) {
				  var properties = (selection.feature.properties)
				  showPopup(selection.leaflet_event.latlng, properties);
				} else {
				  map.closePopup();
				}
			  },
			  //load: queryViewport
			  load: function(){
			  	console.log('load')
			  	queryViewport()
			  	applyURLQuery() // does not fire?
			  },
			  view_complete: function(){
			  	console.log('view complete')
			  	queryViewport()
			  	applyURLQuery() // does not fire
			  }
			  
			}
		  });   
	
		layer.addTo(map);
	}

	function inputSpace(){
	
		// creates text input fields if no space id or token in the url
	
		var br = document.createElement("br");
		
		var space_input_label = document.createElement("label");
		var space_input_description = "XYZ space ID"
		var space_input = document.createElement("INPUT");
		space_input.setAttribute("type", "text");
		space_input.name = 'space_input'
		space_input.id = 'space_input'
		space_input.placeholder = "enter an XYZ space ID"

		
		var token_input_label = document.createElement("label");
		var token_input_description = "XYZ token"
		var token_input = document.createElement("INPUT");
		token_input.name = 'token_input'
		token_input.id = 'token_input'
		token_input.setAttribute("type", "text");
		token_input.placeholder = "enter an XYZ token"
		
		space_input_label.innerHTML = space_input_description
		space_input_label.appendChild(space_input);   // add the box to the element
		
		token_input_label.innerHTML = token_input_description
		token_input_label.appendChild(token_input);   // add the box to the element

		document.getElementById("spaces").appendChild(space_input);
		document.getElementById("spaces").appendChild(br);
		document.getElementById("spaces").appendChild(token_input);
		document.getElementById("spaces").appendChild(br);


		var get_space_text = document.createElement("p");
		get_space_text.style = "color:blue;"
		get_space_text.innerHTML = ('Show XYZ Space')
		get_space_text.onclick = () => {
			getSpace()
		}
		document.getElementById("spaces").appendChild(get_space_text)	
		
		
	}
	
	
	function getSpace(){
		if ((!space) && (document.getElementById("space_input").value)){
			console.log('no space and token in url, looking in text input boxes')
			space = document.getElementById("space_input").value
			token = document.getElementById("token_input").value
			console.log(space,token)
			var url_custom = 'https://xyz.api.here.com/hub/spaces/' + space +  '/tile/web/{z}_{x}_{y}'
			
			layer.scene.load({    
				import: [
					'https://www.nextzen.org/carto/refill-style/refill-style.zip',
					'https://www.nextzen.org/carto/refill-style/themes/color-gray-gold.zip',
					'https://www.nextzen.org/carto/refill-style/themes/label-4.zip',
					'https://www.nextzen.org/carto/refill-style/themes/terrain-shading-dark.zip',
					'https://s3.amazonaws.com/xyz-demo/data/demo.yaml',
					'tangram_xyz_scene_no_import.yaml'
				],
				sources: {
					 _xyzspace: {
						url: url_custom,
						url_params: {
							access_token: token,
							tags: tags_filtered
						}
					}
				}
			})
			getBbox(space,token)
		}	
		else {

			layer.scene.config.sources._xyzspace.url = 'https://xyz.api.here.com/hub/spaces/' + space +  '/tile/web/{z}_{x}_{y}'
			layer.scene.config.sources._xyzspace.url_params.access_token = token
			layer.scene.config.sources._xyzspace.url_params.tags = tags_filtered
// 			applyURLQuery() // getting desperate
			layer.scene.updateConfig()

		}

    }
	    
	function filterTags(x){
		console.log('tag',x)
		var checkbox_status = document.getElementById(x).checked
		console.log(x,'checked',checkbox_status)
		// if checkbox was just unchecked, remove tag from list 
		if (checkbox_status == false){
			console.log('removing',x,'from',tags_filtered)
// 			document.getElementById(x).checked = false
			var index = tags_filtered.indexOf(x)
			// remove the tag
			if (index > -1) {
				tags_filtered.splice(index, 1);
				console.log('removing tag',x,tags_filtered)
				drawTags()
// 			  return
			}
		}
		// otherwise add it to the list
		else {
			tags_filtered.push(x)
		}
// 		console.log(checkbox_status,'status')

		drawTags()
	}
	
	function addTagsToQuery()	{
		if (tags_filtered.includes('+')){
			query.tags = tags_filtered.toString('+')
		}
		if (tags_filtered.includes(',')){
			query.tags = tags_filtered.toString(',')
		}	
		makeQuery(query)
	
	}
		
	function drawTags(){

		// change array to string. if AND, swap out commas for + so XYZ tags are AND, otherwise just use commas for XYZ OR
		var tags_to_tangram
		var tags_to_tangram_label
		query.tags = tags_filtered // add tags to url query
		if (and_or == 'and'){
			tags_to_tangram = tags_filtered.toString().replace(/,/,'+')
			tags_to_tangram_label = tags_filtered.toString().replace(/,/,' AND ')
			console.log('and',tags_to_tangram,tags_to_tangram_label)

		}
		else if (and_or =='or'){
			tags_to_tangram = tags_filtered.toString()
			tags_to_tangram_label = tags_to_tangram.replace(/,/,' OR ')
			console.log('or',tags_to_tangram,tags_to_tangram_label)

		}
		var label = "filtering by tags:<br>" + tags_to_tangram_label
		if (tags_to_tangram_label == ''){label += 'none'}
// 		console.log(label,tags_to_tangram)
// 		console.log("innerhtml",document.getElementById("tags_filtered").innerHTML)
		document.getElementById("tags_filtered").innerHTML = label
		// tell tangram to filter by tags by changing the url_param
		layer.scene.config.sources._xyzspace.url_params.tags = tags_to_tangram
		layer.scene.updateConfig()
	}
	    
	function clearTags(){
		tags_filtered = []
		
		delete query.tags
		makeQuery(query)
		
		layer.scene.config.sources._xyzspace.url_params.tags = ""
		layer.scene.updateConfig()
		document.getElementById("tags_filtered").innerHTML = "no tags filtered<br><br>"
		
		queryViewport()
		
	}
	
	function filterAts(){
		if (filterAt){
			console.log('showing all tags')
			document.getElementById("at_filter").innerHTML = '[only show @ tags]'

			filterAt = false
		} 
		else {
			console.log('only showing @ tags')
			document.getElementById("at_filter").innerHTML = '[show all tags]'

			filterAt = true
		}
		queryViewport()
	}
	
	function alphabetize_tags(){
		if (alphabetize){
			console.log('sorting tags by frequency')
			document.getElementById("alphabetize").innerHTML = '[sort by name]'
			alphabetize = false
		}
		else{
			console.log('sorting tags by name')
			document.getElementById("alphabetize").innerHTML = '[sort by frequency]'
			alphabetize = true
		}
		queryViewport()

	
	}
	
	function toggleAnd(){
		and_or = "and"
		console.log('and tags')
		drawTags()
		
	}
	function toggleOr(){
		and_or = "or"
		console.log('or tags')
		drawTags()

	}	

	
	function parseQuery (qstr) {
		var query = {};
		var a = qstr.split('&');
		for (var i in a) {
			var b = a[i].split('=');
			query[decodeURIComponent(b[0])] = decodeURIComponent(b[1]);
			}
		return query;
	}
	
	function makeQuery(queryParams){
		var esc = encodeURIComponent;
		var updated_query = Object.keys(queryParams)
			.map(k => esc(k) + '=' + esc(queryParams[k]))
			.join('&');
		updated_query = '?' + updated_query + window.location.hash  // why is this ? necessary
		console.log(updated_query)
// 		window.location.search = updated_query
		window.history.replaceState(null,null,updated_query)
// 		window.history.pushState = updated_query
		displayQuery()
	}
	    
	function showPopup(latlng, properties) {
	 	var feature_tags = properties['@ns:com:here:xyz'].tags
		property_text = ''
		const keys = Object.keys(properties)
		const values = Object.values(properties)
	    traverse(properties, "!!") // gotta be a better way to do this
// 	    console.log(property_text)
	    var formatted = property_text.replace(/:!!/g,":&nbsp;&nbsp;")
// 	    console.log(formatted)
	    formatted = formatted.replace(/!!/g,"<br>&nbsp;&nbsp;")
	    formatted = formatted.replace(/<br>&nbsp;&nbsp;{object}<br>/g,'{object}<br>')
// 	    console.log(formatted)

		document.getElementById("properties").innerHTML = formatted

	}
	



	
	function colorProperties(x){
		console.log('property', x)
		color_by_prop = true
		var target = x.split('@')
// 		property_target = target[0]
		layer.scene.config.global.property_hash_name = target[0]
		layer.scene.config.layers._xyz_dots.draw.points.color = layer.scene.config.global.var_property_color_hash
		layer.scene.config.layers._xyz_lines.draw._lines.color = layer.scene.config.global.var_property_color_hash
		layer.scene.config.layers._xyz_polygons.draw._polygons_inlay.color = layer.scene.config.global.var_property_color_hash
		layer.scene.config.layers._xyz_polygons._outlines.enabled = false
		layer.scene.updateConfig()
		// document.getElementById("colorProperties").innerHTML = 'coloring by property: ' + target[0]
		console.log('sending',target[0],'to panel')
		queryPropsViewport(target[0])
	
	}
	
	function clearColorProperties(){
		color_by_prop = false
		layer.scene.config.layers._xyz_lines.draw._lines.color = 'global.color_lines'
		layer.scene.config.layers._xyz_dots.draw.points.color = 'global.color_points'
		layer.scene.config.layers._xyz_polygons.draw._polygons_inlay.color = 'global.color_polygons'
		layer.scene.updateConfig()
		document.getElementById("prop_stats").innerHTML = ''
		delete query.property
		makeQuery(query)
	}
	
	function colorHash(value){
		var props = JSON.stringify(value)
// 		console.log(props)
		var hash = 0, i, chr;
		if (props === 0){hash = 0};
		for (i = 0; i < props.length; i++) {
			chr   = props.charCodeAt(i);
			hash  = ((hash << 5) - hash) + chr;
			hash |= 0; // Convert to 32bit integer
		}
		var color = 'hsla(' + hash + ', 100%, 50%, 0.75)'
// 		console.log(color)
		return color
	}
	
	function traverse(x,level,key) { // added key so we can pass key@value to colorProperties
	  if (isArray(x)) {
		traverseArray(x, level,key);
	  } else if ((typeof x === 'object') && (x !== null)) {
		traverseObject(x, level);
	  } else {
// 		console.log(level + x);
		var _x = x + '' //x.toString()
		_x = _x.replace(/ /g,'_') 
		_x = _x.replace(/&/g,'and') 

// 		console.log(_x)
		_x = key + "@" + _x
		var text = level + '<y onclick=colorProperties(\'' + _x + '\')>' + x + '</y>'
		property_text += text
	  }
	}
 
	function isArray(o) {
	  return Object.prototype.toString.call(o) === '[object Array]';
	}
 
	function traverseArray(arr, level,key) {
// 	  console.log(level + "[array]");
	  var text = level + "[array]"
	  property_text += text
	  arr.forEach(function(x) {
		traverse(x, level + "&nbsp;&nbsp;",key);
	  });
	}
 
	function traverseObject(obj, level) {
// 	  console.log(level + "{object}");
	  var text = level + "{object}"
	  property_text += text
	  for (var key in obj) {
		if (obj.hasOwnProperty(key)) {
// 		  console.log(level + "" + key + ":");
		  var text = level + "" + key + ":"
		  property_text += text
		  traverse(obj[key], level + "&nbsp;&nbsp;&nbsp;&nbsp;",key);
		}
	  }
	}
	
	
	function buildTable(obj,div){
		console.log("building table",div,Object.keys(obj).length)
		console.log(Object.keys(obj))
// 		var x = document.createElement("TABLE");
		var tbody = document.getElementById(div);
		console.log('tbody:',tbody)
		var rows = Object.entries(obj)
		console.log(rows)
		rows.forEach((item,index) => {
			
			var tr = "<tr>";
			console.log("making row")
			var stats = item[index] //var id = Object.keys(space_list)[index]
			var id = rows[stats]
			var values = Object.values(stats)
			tr += "<td>" + id + "</td>"
			values.forEach( (item,index) =>{
				tr += "<td>" + values + "</td>";
			})
			/* We add the table row to the table body */
			tr += "</tr>"
			console.log(tr)
			tbody.innerHTML += tr;
		})
	} // https://stackoverflow.com/questions/17684201/create-html-table-from-javascript-object
	
	
	function buildSelect(list){
		var sel = document.getElementById("spaceSelect")
// 		opt.onchange = function(){
// 		layer.scene.config.sources._xyzspace.url = 'https://xyz.api.here.com/hub/spaces/' + x.id +  '/tile/web/{z}_{x}_{y}'
// 				layer.scene.updateConfig();
// 			}
		list.forEach(x => { 
			var opt = document.createElement("option");

			opt.value = x.id
			opt.text = x.title + '/' + x.description
			sel.add(opt, null);
		})
		
	}

	function listSpaces(token){
		var url = 'https://xyz.api.here.com/hub/spaces/?access_token=' + token
		fetch(url).then((response) => response.json()).then(function(data) {
		document.getElementById("tableLabel").innerHTML = "getting stats for " + data.length + " spaces (may take a bit)"

// 			console.log(data)
// 			buildSelect(data)
			// make an object with each space id as the key
			var id
			// populate the object
			data.forEach (item => {
				id = item.id
				// console.log(id)
				space_list[id] = {}
				space_list[id].title = item.title
				space_list[id].description = item.description
			})
			
			//make list of URLs for stats
			const urls = data.map(x => 'https://xyz.api.here.com/hub/spaces/' + x.id + '/statistics' + '?access_token=' + token);
			// fetch the urls and dump them into an object
			const promises = urls.map(url => fetch(url).then(y => y.json()));
			// once all the /statistics response are collected (up to 30 secs) iterate throug them
			Promise.all(promises).then(space_data => {
				// console.log(space_data)
				// loop through everything returned in the promise (returned in same order as asked)
					space_data.forEach((item,index) => {
						// console.log(index)
// 						console.log(Object.keys(space_list)[index])
						// figure out the key for that same point in the list of spaces
						var id = Object.keys(space_list)[index]
						// add the stats to that's space's space_list object
						console.log(item.type)
						if (item.type == "StatisticsResponse"){
							space_list[id].bbox = item.bbox.value
							space_list[id].space_size = item.byteSize.value
							space_list[id].space_count = item.count.value
						} 
						else {
							space_list[id].bbox = "n/a"
							space_list[id].space_size = "n/a"
							space_list[id].space_count = "n/a"
						}
						
					})
// 					var table_div = document.getElementById("spaceTable")
					buildTable(space_list,"spaceTablebody")
				})
			})
// 		console.log('space list:', space_list)
// 		buildSelect(space_list)
		}
	
	function getStats(space,token){
		var url = 'https://xyz.api.here.com/hub/spaces/' + space + '/statistics' + '?access_token=' + token
		fetch(url).then((response) => response.json()).then(function(data) {
// 			console.log(data)
			var bbox = data.bbox.value
			console.log('map start location:', map_start_location)
			console.log('bbox',bbox)
			if (map_start_location){
			// if there is a map hashtag and it is outside the bbox, recenter, but if it's inside, keep that view
				if (
					((map_start_location.lat < bbox[1]) || (map_start_location.lat > bbox[3])) 
					|| 
					((map_start_location.lng < bbox[0]) || (map_start_location.lng > bbox[2]))
				){
					console.log('map start location outside bbox')
					var corner1 = L.latLng(bbox[1],bbox[0]),
					corner2 = L.latLng(bbox[3],bbox[2])
					bounds = L.latLngBounds(corner1, corner2)
					map.fitBounds(bounds)
					}
			}
			var space_size = data.byteSize.value
			var space_count = data.count.value
			var calc_size = (space_size/1024/1024)
			console.log(space_size,'KB',calc_size)
			if (calc_size < 1000){
				calc_size = calc_size.toFixed(1) + ' MB'
// 				console.log(calc_size,'MB!')
				}
			else{
				calc_size = (space_size/1024/1024/1024).toFixed(1) + ' GB'
// 				console.log(calc_size,'GB!')
				}
			 
// 			var density = 
// 			console.log(bbox,mb,space_count)
			var space_url = 'https://xyz.api.here.com/hub/spaces/' + space + '?access_token=' + token
			fetch(space_url).then((response) => response.json()).then(function(data) {
// 				console.log(data)
				var title = data.title
				var description = data.description
// 				console.log(space,title,description,calc_size,space_count)
				document.getElementById("space_info").innerHTML = space + ': ' + title + '<br>' + space_count.toLocaleString() + " features, " + calc_size + '<br>' + description 

			})

		})
	}
	
	function getBbox(){
		var url = 'https://xyz.api.here.com/hub/spaces/' + space + '/statistics' + '?access_token=' + token
		fetch(url).then((response) => response.json()).then(function(data) {
			var bbox = data.bbox.value
			// check for all zero bbox
			if ((bbox[0] == 0) && (bbox[1] == 0) && (bbox[2] == 0) && (bbox[3] == 0)){
				console.log('zeros')
				bbox = [-45,-45,45,45]
				}
			console.log(bbox)
			var sw = L.latLng(bbox[1],bbox[0]),
			ne = L.latLng(bbox[3],bbox[2])
			console.log("sw",sw,'ne',ne)
			bounds = L.latLngBounds(sw, ne)
			console.log('bounds:', bounds)	
			// console.log(map)
			
			map.fitBounds(bounds);
			
			console.log('got bounds')
			getStats(space,token)
		})
	}
	
	
	function queryViewport(){ // for tags
		tagsViewport = []
		layer.scene.queryFeatures({ filter: { $source: '_xyzspace' }}).then(
			features => {
				// clear the previously seen list of tags
				document.getElementById("tag_stats").innerHTML = ''
				// console.log("features in viewport:", features.length)
				//grab the tags from Tangram's viewport 
				features.forEach(x => { 
					tagsViewport.push(...x.properties['@ns:com:here:xyz'].tags)
				})
				
				//remove tags without an @ if 
				if (filterAt){
					tagsViewport = tagsViewport.filter(tag => tag.includes('@'))
				}

				// add this to the tag set
				tagsViewport.forEach(x => {tagSet.add(x)})
				// console.log('unique tags seen so far',[...tagSet].sort())

				// console.log("tags in viewport:", tagsViewport.length)
				const counts = {}
				const total_tags_seen = {}
				// count them
				tagsViewport.forEach(function(x) { counts[x] = (counts[x] || 0)+1; });
				tagSet.forEach(function(x) { total_tags_seen[x] = (total_tags_seen[x] || 0)+1; });

// 				console.log(tagsViewport)
				// console.log("unique tags in viewport:",Object.keys(counts).length)
				//make the tag stats table
				var row_1 = "<tr><td>features in viewport</td><td>" + features.length + "</td><tr>"
				var row_2 = "<tr><td>tags in viewport</td><td>" + tagsViewport.length + "</td><tr>"
				var row_3 = "<tr><td>unique tags in viewport</td><td>" + Object.keys(counts).length + "</td><tr>"
				var row_4 = "<tr><td>unique tags seen</td><td>" + Object.keys(total_tags_seen).length + "</td><tr>"
				var table = "<table>" + row_1 + row_2 + row_3 + row_4 + "</table>"
				// add it to the div
				var newEl = document.createElement("x")
				newEl.innerHTML = table
// 					newEl.onclick = () => {
// 						filterTags(x)
// 						}
				document.getElementById("tag_stats").appendChild(newEl)
			
				// count up the number of each tags
				var tagCounts = {};
				for (var i = 0; i < tagsViewport.length; i++) {
				  var num = tagsViewport[i];
				  tagCounts[num] = tagCounts[num] ? tagCounts[num] + 1 : 1;
				}
				// console.log("tag counts: ",tagCounts)
				// sort the list of tags by count
				var sortable = [];
				// make a new list of tags and their counts
				for (var aTag in tagCounts) {
					sortable.push([aTag, tagCounts[aTag]]);
				}

				sortable.sort(function(a, b) {
					return b[1] - a[1];
				});		
				
				// console.log("sorted tag counts: ", sortable)

				if (alphabetize){
					console.log('alphabetizing')
					var alpha = []
					for (var aTag in tagCounts) {
						alpha.push([aTag, tagCounts[aTag]]);
					}			
					alpha.sort()
					//console.log('descending',alpha)	
					sortable = alpha
					
				}

				document.getElementById("tags").innerHTML  = ''
// 				tagsViewport.sort().map(x =>{ 
				// make checkboxes				
				sortable.map(x =>{ 
				
					var label = document.createElement("label");
					if (alphabetize){
						var description = document.createTextNode(x[0] + ' (' + x[1] + 'x)');
					}
					else{
						var description = document.createTextNode('(' + x[1] + 'x) ' + x[0]);
					}
					var checkbox = document.createElement("input");
					var br = document.createElement("br");
					
					checkbox.setAttribute("type", "checkbox");
					
					var index = tags_filtered.indexOf(x[0]);
					if (index > -1) {
						checkbox.checked = true
					}
					
					checkbox.name = x[0]
					checkbox.value = x[0]
					checkbox.id = x[0]
					checkbox.onclick = () => {
						filterTags(x[0])
					}
					label.appendChild(checkbox);   // add the box to the element
					label.appendChild(description);// add the description to the element

					// add the label element to your div
					document.getElementById('tags').appendChild(label);
					document.getElementById('tags').appendChild(br);
				})				
			}
		)
    }
    
	// via https://www.quora.com/How-do-you-loop-through-a-complex-JSON-tree-of-objects-and-arrays-in-JavaScript

	function queryPropsViewport(clicked){ // for tags
		console.log('received',clicked)
		query.property = clicked
		makeQuery(query)
		console.log('query.property:',query.property)
		propsViewport = []
		layer.scene.queryFeatures({ filter: { $source: '_xyzspace' }}).then(
			features => {

				
				// clear the previously seen list of tags

 				document.getElementById("prop_stats").innerHTML = ''
				console.log("features in viewport:", features.length)
				//grab the tags from Tangram's viewport 
				features.forEach(x => {
					propsViewport.push(x.properties[clicked])
				})
				const counts = {}
				const total_props_seen = {}
				// count them
				propsViewport.forEach(function(x) { counts[x] = (counts[x] || 0)+1; });
				var rows = ''
				var propsUnique = Object.keys(counts).length + " unique values of <i>" + clicked +  "</i> in viewport"
				document.getElementById("colorProperties").innerHTML = propsUnique
// 				rows += row_summary

				// count up the number of each property value
				var propCounts = {};
				for (var i = 0; i < propsViewport.length; i++) {
				  var num = propsViewport[i];
				  propCounts[num] = propCounts[num] ? propCounts[num] + 1 : 1;
				}
// 				console.log("prop counts: ",propCounts)
				// sort the list of tags by count
				var sortable = [];
				// make a new list of tags and their counts
				for (var aTag in propCounts) {
					sortable.push([aTag, propCounts[aTag]]);
				}

				sortable.sort(function(a, b) {
					return b[1] - a[1];
				});	
				

				//console.log("sorted prop counts: ", sortable)

// 				document.getElementById("prop_list").innerHTML  = sortable
				// make table	
// 				console.log('rows',rows)			
				sortable.map(x =>{ 
// 					console.log(x)
					var color =  colorHash(x[0]) // same color hash as tangram 
					var dot = '<span class="dot" style="background-color:' + color + ';"> </span>'
					var row = '<tr><td style="width: 15px;text-align: right;">' + x[1] + '</td><td style="width: 15px;">' +  dot +'</td><td>'+ x[0] + '</td></tr>'
					rows += row
					// console.log('rows',rows)			

				})			
// 				console.log(rows)

				document.getElementById("prop_stats").innerHTML = rows
			}
		)
    }
    



        
	
</script>
</body>
</html>
