<!doctype html>
<html lang="en-us">
<head>
  <meta charset="utf-8">
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>HERE XYZ Space Invader</title>
  <link href="space-invader-144-294760.png" rel="icon" type="image/x-icon" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.4.0/dist/leaflet.css" />
  <!-- <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/bulma/0.7.4/css/bulma.min.css" /> -->

  <style>
  html, body {
    margin: 0;
    border: 0;
    font-family: 'Fira Sans', sans-serif;
    font-size: 12px;
    /* height: 100%; */
    }

  #map {
      height: 100%;
      width: 100%;
    position: absolute;
  }

  </style>
</head>
<body>
<div id="map"></div>
<div id="ui"></div>

<script src="https://unpkg.com/leaflet@1.4.0/dist/leaflet.js"></script>
<script src="https://unpkg.com/lodash@4.17.11/lodash.min.js"></script>
<!-- Main tangram library -->
<script src="https://unpkg.com/tangram/dist/tangram.debug.js"></script>
<!-- <script src="http://localhost:8000/dist/tangram.debug.js"></script> -->
<script src="leaflet-hash.js"></script>

<!-- <script type="module"> -->
<script src="AppUI.js"></script>
<script src="basemaps.js"></script>
<script src="displayOptions.js"></script>
<script>
  var query;
  var layer;
  var scene_config
  var map, hash, popup;

  map = L.map('map', {boxZoom: false});
    hash = new L.Hash(map);
    popup = L.popup();

  // Leaflet needs an initial location before the map is "ready", which will block Tangram layer loading
  map.setView([37.7,-122.4], 2);

  map.zoomControl.setPosition('bottomright')

  // grab query parameters from the url and assign them to globals
  query = new URLSearchParams(document.location.search);

  var url_hash = window.location.hash.slice(1, window.location.hash.length).split('/');
  var mapStartLocation = null
  if (url_hash.length == 3) {
    mapStartLocation = {
      lat: Number(url_hash[1]),
      lng: Number(url_hash[2]),
      zoom: Number(url_hash[0])
    };
  }

  // Initialize App UI
  const appUI = new AppUI({
    target: document.getElementById('ui')
  });

  // Handle UI events affecting Tangram scene
  appUI.on('loadScene', ({ basemapScene }) => {
    loadScene(basemapScene);
  });

  appUI.on('updateScene', state => {
    if (scene_config) {
      updateScene(state);
      scene.updateConfig();
    }
  });

  // Load info on a new XYZ space
  appUI.on('loadSpace', ({ spaceId, token }) => {
    if (mapStartLocation == null) {
      console.log('no url hash, getting bbox');
      getBbox({ spaceId, token });
    } else {
      console.log('using url hash', mapStartLocation);
      map.setView([mapStartLocation.lat,mapStartLocation.lng],mapStartLocation.zoom);
      getStats({ spaceId, token });
    }
  });

  // Handle query string updates
  appUI.on('updateQueryString', ({ queryParams }) => {
    const query = new URLSearchParams(queryParams);
    const qs = `?${query.toString()}${window.location.hash}`;
    window.history.replaceState(null, null, qs);
  });

  // Initialize UI with query string params
  appUI.setFromQueryParams(query);

  // apply updates to scene based on current display options
  function updateScene({ spaceId, token, displayToggles, selectedFeatureProp, tagFilterQueryParam }) {
    applySpace({ spaceId, token });

    // display options such as point size, toggling buildings or roads on/off, etc.
    applyDisplayOptions(displayToggles);

    // color features by a specific property (if a property is currently selected)
    applyFeatureColor(selectedFeatureProp);

    // update the tag filter on the XYZ tiles (if the tags have changed, this will cause new tiles to load)
    applyTags(tagFilterQueryParam);
  }

  // load a new scene basemap (first creating the leaflet and tangram layers if needed)
  function loadScene(scene_obj) {
    if (layer == null) {
      // if the Tangram layer doesn't exist yet, initialize it and load the scene for the first time
      makeLayer(scene_obj);
    }
    else {
      scene.load(scene_obj);
    }
  }

  // initialize Tangram leaflet layer, and load the scene for the first time
  function makeLayer(scene_obj) {
    layer = Tangram.leafletLayer({
      scene: scene_obj,
      attribution: '<a href="https://github.com/tangrams/tangram" target="_blank">Tangram</a> | &copy; OSM contributors | <a href="https://explore.xyz.here.com/">HERE XYZ</a>',
      events: {
        hover: function({ feature }) {
          if (feature && feature.source_name === '_xyzspace') {
            // let the UI know we're hovering over a new feature
            appUI.set({ selectedFeature: feature });
          }
        }
      }
    });

    // setup Tangram event listeners
    layer.scene.subscribe({
      load: function ({ config }) {
        // when a new scene loads (e.g. when app loads, or a new basemap is selected),
        // update with current data source and display options
        scene_config = config;
        updateScene(appUI.get());
      },
      view_complete: function (e) {
        // when new tiles finish loading, update viewport counts for tags and feature properties
        console.log('view complete')
        queryViewport();
      }
    });

    layer.addTo(map);

    window.layer = layer; // debugging
    window.scene = layer.scene;  // debugging
  }

  function applySpace({ spaceId, token }) {
    if (spaceId && token) {
      _.merge(scene_config, {
        sources: {
          _xyzspace: {
            url: 'https://xyz.api.here.com/hub/spaces/' + spaceId + '/tile/web/{z}_{x}_{y}',
            url_params: {
              access_token: token
            }
          }
        }
      });
    }
  }

  function applyDisplayOptions(options) {
    for (const option in options) {
      const value = options[option];
      if (displayOptions[option] && displayOptions[option].apply) {
        displayOptions[option].apply(scene_config, value);
      }
    }
  }

  function applyFeatureColor(prop) {
    if (appUI.get().displayToggles.randomColors) {
      return;
    }

    console.log('property', prop)
    if (prop) {
      scene_config.global.property_hash_name = prop;
      scene_config.layers._xyz_dots.draw.points.color = scene_config.global.var_property_color_hash
      scene_config.layers._xyz_lines.draw._lines.color = scene_config.global.var_property_color_hash
      scene_config.layers._xyz_polygons.draw._polygons_inlay.color = scene_config.global.var_property_color_hash
      scene_config.layers._xyz_polygons._outlines.enabled = false
    }
    else {
      scene_config.layers._xyz_lines.draw._lines.color = scene_config.global.color_lines;
      scene_config.layers._xyz_dots.draw.points.color = scene_config.global.color_points;
      scene_config.layers._xyz_polygons.draw._polygons_inlay.color = scene_config.global.color_polygons;
    }
  }

  function applyTags(tagFilterQueryParam) {
    _.merge(scene_config, {
      sources: {
        _xyzspace: {
          url_params: { tags: tagFilterQueryParam }
        }
      }
    });

    // remove tags param if no tags - do this after merge above, to ensure the full object path exists
    // (created by merge if doesn't exists already)
    if (!tagFilterQueryParam) {
      delete scene_config.sources._xyzspace.url_params.tags;
    }
  }

  async function getStats({ spaceId, token }) {
    // Get stats endpoint
    var url = `https://xyz.api.here.com/hub/spaces/${spaceId}/statistics?access_token=${token}`;
    const stats = await fetch(url).then(r => r.json());
      // console.log(stats)

    var bbox = stats.bbox.value
    console.log('map start location:', mapStartLocation)
    console.log('bbox',bbox)
    if (mapStartLocation){
    // if there is a map hashtag and it is outside the bbox, recenter, but if it's inside, keep that view
      if (
        ((mapStartLocation.lat < bbox[1]) || (mapStartLocation.lat > bbox[3]))
        ||
        ((mapStartLocation.lng < bbox[0]) || (mapStartLocation.lng > bbox[2]))
      ){
        console.log('map start location outside bbox')
        var corner1 = L.latLng(bbox[1],bbox[0]),
        corner2 = L.latLng(bbox[3],bbox[2])
        bounds = L.latLngBounds(corner1, corner2)
        map.fitBounds(bounds)
        }
    }
    var spaceSize = stats.byteSize.value
    var spaceCount = stats.count.value
    var calcSize = (spaceSize/1024/1024)
    console.log(spaceSize,'KB',calcSize)
    if (calcSize < 1000){
      calcSize = calcSize.toFixed(1) + ' MB'
      }
    else{
      calcSize = (spaceSize/1024/1024/1024).toFixed(1) + ' GB'
      }

    // Get space endpoint
    var spaceURL = `https://xyz.api.here.com/hub/spaces/${spaceId}?access_token=${token}`;
    const spaceInfo = await fetch(spaceURL).then((response) => response.json());

    // updated document title
    document.title = document.title + " / " + spaceId + " / " + spaceInfo.title

    // update UI
    appUI.set({
      // spaceId,
      spaceInfo: {
        title: spaceInfo.title,
        description: spaceInfo.description,
        numFeatures: spaceCount,
        dataSize: calcSize
      },
      // token
    });
  }

  function getBbox({ spaceId, token }) {
    var url = 'https://xyz.api.here.com/hub/spaces/' + spaceId + '/statistics' + '?access_token=' + token
    fetch(url).then((response) => response.json()).then(function(data) {
      var bbox = data.bbox.value
      // check for all zero bbox
      if ((bbox[0] == 0) && (bbox[1] == 0) && (bbox[2] == 0) && (bbox[3] == 0)){
        console.log('zeros')
        bbox = [-45,-45,45,45]
        }
      console.log(bbox)
      var sw = L.latLng(bbox[1],bbox[0]),
      ne = L.latLng(bbox[3],bbox[2])
      bounds = L.latLngBounds(sw, ne)
      map.fitBounds(bounds);
      getStats({ spaceId, token })
    })
  }

  // query Tangram viewport tiles, and update UI data (tag and property counts, etc.)
  async function queryViewport() {
    const features = await scene.queryFeatures({ filter: { $source: '_xyzspace' }});
    console.log("features in viewport:", features.length);
    updateViewportTags(features);
    updateViewportProperties(features);
  }

  function updateViewportTags(features) {  // for tags
    // grab the tags from Tangram's viewport tiles
    let tagsViewport = [];
    features.forEach(x => {
      tagsViewport.push(...x.properties['@ns:com:here:xyz'].tags)
    })

    // count them
    const counts = {}
    tagsViewport.forEach(function(x) { counts[x] = (counts[x] || 0)+1; });

    // count up the number of each tags
    var tagCounts = {};
    for (var i = 0; i < tagsViewport.length; i++) {
      var num = tagsViewport[i];
      tagCounts[num] = tagCounts[num] ? tagCounts[num] + 1 : 1;
    }
    // console.log("tag counts: ",tagCounts)
    // sort the list of tags by count
    var sortable = [];
    // make a new list of tags and their counts
    for (var aTag in tagCounts) {
      sortable.push([aTag, tagCounts[aTag]]);
    }
    sortable.sort((a, b) => b[1] - a[1]);

    appUI.set({
      numFeaturesInViewport: features.length,
      tagsInViewport: tagsViewport,
      tagsWithCounts: sortable
    });
  }

  function updateViewportProperties(features) { // for feature prop
    const prop = appUI.get().selectedFeatureProp;

    if (!prop) {
      appUI.set({
        selectedFeaturePropCount: null,
        selectedFeaturePropValueCounts: null
      });
      return;
    }

    // grab the feature properties from Tangram's viewport tiles
    const propsViewport = features.map(x => x.properties[prop]);

    // count them
    const counts = propsViewport.reduce((obj, x) => {
      obj[x] = (obj[x] || 0) + 1;
      return obj;
    }, {});

    // count up the number of each property value
    var propCounts = {};
    for (var i = 0; i < propsViewport.length; i++) {
      var num = propsViewport[i];
      propCounts[num] = propCounts[num] ? propCounts[num] + 1 : 1;
    }

    // sort the list of properties by count
    const sortable = Object.entries(propCounts).sort((a, b) => b[1] - a[1]);

    // update UI
    appUI.set({
      selectedFeaturePropCount: Object.keys(counts).length,
      selectedFeaturePropValueCounts: sortable
    });
  }

</script>
</body>
</html>
