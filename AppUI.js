/* AppUI.svelte generated by Svelte v2.16.1 */
(function(global, factory) {
	typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() :
	typeof define === "function" && define.amd ? define(factory) :
	(global.AppUI = factory());
}(this, (function () { "use strict";

	// import displayOptions from './displayOptions';

function basemapScene({ basemap }) {
  return {
    ...getBasemapScene(basemap),
    ...{ global: { colorFunctions } }
  };
}

	function featurePropRows({ feature }) {
		return feature && buildFeatureRows(feature.properties);
	}

	function featurePropPalette({ featurePropPaletteName }) {
  return colorPalettes[featurePropPaletteName];
}

	function sortedFeaturePropValueCounts({ featurePropValueCounts, featurePropValueSort }) {
  if (featurePropValueSort === 'values') {
    // copy and re-sort on value (descending) if needed
    return Array.from(featurePropValueCounts).sort((a, b) => {
      // try to get a number
      let an = parseFloat(a[0]);
      let bn = parseFloat(b[0]);

      // sort nulls and NaNs to the bottom
      an = (an == null || isNaN(an)) ? -Infinity : an;
      bn = (bn == null || isNaN(bn)) ? -Infinity : bn;

      return bn - an; // descending sort
    });
  }
  return featurePropValueCounts; // return original/unmodified values
}

	function featurePropValueCountHash({ featurePropValueCounts }) {
		return hashString(JSON.stringify(featurePropValueCounts));
	}

	function nextFeaturePropValueSort({ featurePropValueSort }) {
		return featurePropValueSort === 'count' ? 'values' : 'count';
	}

	function nextTagSort({ tagSort }) {
		return tagSort === 'count' ? 'name' : 'count';
	}

	function uniqueTagsInViewport({ tagsWithCountsInViewport }) {
		return new Set(tagsWithCountsInViewport.map(v => v[0]));
	}

	function numFeatureTagsInViewport({ tagsWithCountsInViewport }) {
		return tagsWithCountsInViewport.reduce((acc, cur) => acc + cur[1], 0);
	}

	function tagDisplayList({ tagsWithCountsInViewport, tagSort, tagFilterList, tagFilterViewport, tagFilterAt, tagFilterSearch, uniqueTagsSeen }) {
  const tagCountMap = new Map();

  // optional filters
  // e.g. remove tags without an @ if desired, or text search
  const tagFilterFunc = tag => {
    const at = tagFilterAt ? tag.includes('@') : true;
    const search = (tagFilterSearch && tagFilterSearch.length >= 3) ? tag.includes(tagFilterSearch) : true;
    return (at && search) || tagFilterList.indexOf(tag) > -1; // always include selected tags
  };

  // add any tags that are selected, but not currently in the viewport
  // this also handles cases where an impossible tag combo is selected (postcode 98125 AND postcode 98122),
  // but we want those tags to still show up in the list so they can be de-selected
  // note this ignores filters to ensure these tags can always be seen/de-selected
  tagFilterList.forEach(tag => tagCountMap.set(tag, 0));

  // add all uniquely seen tags that aren't currently in the viewport
  if (!tagFilterViewport) {
    uniqueTagsSeen
      .forEach(tag => {
        if (tagFilterFunc(tag)) {
          tagCountMap.set(tag, 0);
        }
      });
  }

  // add tags currently in the viewport
  tagsWithCountsInViewport
    .filter(([tag]) => tagFilterFunc(tag))
    .forEach(([tag, count]) => tagCountMap.set(tag, count));

  // convert to array entries for sorting
  let tagCounts = [...tagCountMap.entries()];

  // sort tags as desired
  if (tagSort === 'name') {
    tagCounts.sort((a, b) => {
      if (a[0] === b[0]) {
        return a[1] < b[1] ? 1 : -1;
      }
      return a[0] > b[0] ? 1 : -1;
    });
  }
  else if (tagSort === 'count') {
    tagCounts.sort((a, b) => {
      if (a[1] === b[1]) {
        return a[0] > b[0] ? 1 : -1;
      }
      return a[1] < b[1] ? 1 : -1;
    });
  }

  return tagCounts;
}

	function tagFilterQueryParam({ tagFilterList, tagFilterAndOr }) {
  if (tagFilterList.length === 0) {
    return null;
  }

  if (tagFilterAndOr === 'and') {
    return tagFilterList.join('+');
  }
  else {
    return tagFilterList.join(',');
  }
}

	function queryParams({ spaceId, token, basemap, displayToggles, featureProp, featurePropPaletteName, featurePropPaletteFlip, tagFilterQueryParam }) {
  const params = new URLSearchParams();

  if (spaceId) {
    params.set('space', spaceId);
  }

  if (token) {
    params.set('token', token);
  }

  params.set('basemap', basemap);

  for(const p in displayToggles) {
    params.set(p, displayToggles[p]);
  }

  if (tagFilterQueryParam) {
    params.set('tags', tagFilterQueryParam);
  }

  if (featureProp) {
    params.set('property', featureProp);
  }

  params.set('palette', featurePropPaletteName);
  params.set('paletteFlip', featurePropPaletteFlip);

  return params;
}

	function data() {
  return {
    // set these to empty strings (not null) to get placeholder text in input
    spaceId: '',
    token: '',
    spaceInfo: null,

    feature: null,
    featureProp: null,
    featurePropCount: null,
    featurePropValueCounts: null,
    featurePropValueSort: 'count',
    featurePropPaletteName: 'viridisInferno', // TODO: move palette to import
    featurePropPaletteFlip: false,
    featurePropMin: null,
    featurePropMax: null,
    featurePropMean: null,
    featurePropMedian: null,
    featurePropStdDev: null,
    featurePropSigma: null,
    featurePropSigmaFloor: null,
    featurePropSigmaCeiling: null,
    featurePropHistogram: null,

    tagsWithCountsInViewport: [],
    tagFilterList: [],
    tagFilterAndOr: 'or',
    tagFilterViewport: false,
    tagFilterAt: false,
    tagSort: 'count',
    tagFilterSearch: '', // set these to empty strings (not null) to get placeholder text in input

    numFeaturesInViewport: null,
    uniqueTagsSeen: new Set(),

    displayToggles: null,
    colorModes: Object.keys(colorFunctions), // make list of color modes accessible to templates
    colorPalettes, // need to reference here to make accessible to templates
    colorHelpers // need to reference here to make accessible to templates
  }
};

	function showFeaturePropColorSwatch(colors) {
  return colorFunctions[colors] && colorFunctions[colors].useProperty;
};

	function showFeaturePropPalette(colors) {
  return colorFunctions[colors] && colorFunctions[colors].usePalette;
};

	function formatFeaturePropValueColor(state, value) {
  const colors = state.displayToggles.colors;
  if (colorFunctions[colors]) {
    return colorFunctions[colors].color(value, state);
  }
  return 'rgba(127, 127, 127, .5)';
};

	function formatFeatureRow(r) {
  const indent = 4;
  let t = Array(r.level * indent).fill('&nbsp;').join('');
  if (r.prop !== undefined) t += r.prop + ': ';
  if (r.value !== undefined) t += r.value;
  return t;
};

	function maybeStringifyObject(v) {
  // stringify objects, otherwise just return original object
  return (v != null && typeof v === 'object') ? JSON.stringify(v) : v;
};

	var methods = {
  setFromQueryParams(params) {
    // convert query params to object
    params = [...params.entries()].reduce((p, [k, v]) => { p[k] = v; return p; }, {});

    // set these to empty strings (not null) to get placeholder text in input
    const spaceId = params.space || '';
    const token = params.token || '';

    // parse out display option toggles
    const toggles = {};
    for (const p in params) {
      if (displayOptions[p]) {
        if (displayOptions[p].parse) {
          // parse display options values (e.g. convert strings to numbers, etc.)
          toggles[p] = displayOptions[p].parse(params[p]);
        }
        else {
          toggles[p] = params[p];
        }
      }
    }

    // set default values for display options
    for (const p in displayOptions) {
      if (toggles[p] == null) {
        toggles[p] = defaultDisplayOptionValue(p);
      }
    }

    // parse tags
    let tagFilterList = [];
    let tagFilterAndOr = this.get().tagFilterAndOr;
    if (params.tags) {
      // look for OR tags
      if (params.tags.includes(',')) {
        tagFilterList = params.tags.split(',');
        tagFilterAndOr = 'or';
      }
      // look for AND tags
      // if (params.tags.includes('+')) {
      else {
        tagFilterList = params.tags.split('+');
        tagFilterAndOr = 'and';
      }
    }

    let basemap = getBasemapName(params.basemap);
    if (!getBasemapScene(basemap)) {
      basemap = getDefaultBasemapName();
    }

    let featurePropPaletteName = this.get().featurePropPaletteName;
    if (colorPalettes[params.palette]) {
      featurePropPaletteName = params.palette;
    }

    this.set({
      spaceId,
      token,
      basemap,
      displayToggles: toggles,
      featureProp: params.property,
      featurePropPaletteName,
      featurePropPaletteFlip: (params.paletteFlip === 'true'),
      tagFilterList,
      tagFilterAndOr
    });

    this.updateSpace(false);
  },

  updateSpace(loadScene) {
    const { spaceId, token, basemapScene } = this.get();

    if (spaceId && token) {
      this.set({
        spaceLoading: true, // used to hide UI during load (maybe replace with promise)
        uniqueTagsSeen: new Set() // reset unique tags when loading new space
      });

      this.fire('loadSpace', {
        spaceId,
        token
      });

      if (loadScene) {
        this.fire('loadScene', {
          basemapScene
        });
      }
    }
  },

  setFeatureProp(featureProp) {
    // if selecting a feature property and current color mode isn't property-specific,
    // automatically change to the 'property' color mode
    const displayToggles = this.get().displayToggles;
    let colors = displayToggles.colors;
    if (colorFunctions[colors] && !colorFunctions[colors].useProperty) {
      colors = 'property';
    }

    this.set({ featureProp, displayToggles: { ...displayToggles, colors } });
  },

  toggleBasemap() {
    this.set({ basemap: getNextBasemap(this.get().basemap) });
  },

  toggleDisplayOption(prop) {
    const displayToggles = this.get().displayToggles;

    const vals = displayOptions[prop] && displayOptions[prop].values;
    if (vals) {
      const i = vals.indexOf(displayToggles[prop]);
      if (i > -1) {
        displayToggles[prop] = vals[(i + 1) % vals.length];
      }
      else {
        displayToggles[prop] = vals[0];
      }
    }

    this.set({ displayToggles });
  },

  toggleFeaturePropValueSort() {
    this.set({ featurePropValueSort: this.get().nextFeaturePropValueSort });
  },

  toggleTagSort() {
    this.set({ tagSort: this.get().nextTagSort });
  },

  toggleTagFilterViewport() {
    this.set({ tagFilterViewport: !this.get().tagFilterViewport })
  },

  toggleTagFilterAt() {
    this.set({ tagFilterAt: !this.get().tagFilterAt })
  },

  handleKeyPress({ key }) {
    // b = toggle buildings
    // c = toggle colors (color hash of all properties, pretty good but some chance of bordering features getting a similar color)
    // h = toggle lines and dot highlights
    // l = colors good for a light basemap
    // o = toggle polygon outlines
    // p = make dots bigger
    // r = toggle roads
    // s = make dots smaller and lines narrower
    // w = put polygons under water

    if (key == "m") { // toggle basemap
      this.toggleBasemap();
    }
    else {
      if (key == "b") { // toggle buildings
        this.toggleDisplayOption('buildings');
      }
      else if (key == "c") { // color hash each feature
        this.toggleDisplayOption('colors');
      }
      else if (key == "h") { // highlight colors and make points bigger
        this.toggleDisplayOption('highlight');
      }
      else if (key == "o") { // toggle polygon outlines
        this.toggleDisplayOption('outlines');
      }
      else if (key == "p") { // make points bigger
        this.toggleDisplayOption('points');
      }
      else if (key == "r") { // toggle roads
        this.toggleDisplayOption('roads');
      }
      else if (key == "l") { // make lines smaller
        this.toggleDisplayOption('lines');
      }
      else if (key == "w") { // put polygons under water
        this.toggleDisplayOption('water');
      }
    }
  }

};

	function onstate({ changed, current, previous }) {
  if (changed.uniqueTagsInViewport) {
    this.set({
      uniqueTagsSeen: new Set([...current.uniqueTagsSeen, ...current.uniqueTagsInViewport])
    });
  }

  // Apply Tangram scene updates based on state change
  if (changed.basemapScene) {
    this.fire('loadScene', current);
  }

  if (changed.displayToggles ||
      changed.tagFilterQueryParam ||
      changed.featureProp ||
      changed.featurePropPalette ||
      changed.featurePropPaletteFlip ||
      changed.featurePropValueCountHash ||
      changed.featurePropMin ||
      changed.featurePropMax // ||
      // changed.featurePropMedian ||
      // changed.featurePropMean ||
      // changed.featurePropStdDev ||
      // changed.featurePropSigma ||
      // changed.featurePropSigmaFloor ||
      // changed.featurePropSigmaCeiling
    ) {

    this.fire('updateScene', current);
  }

  // mark space as loaded
  // used to hide UI during load (maybe replace with promise)
  if (changed.spaceInfo && current.spaceInfo) {
    this.set({
      spaceLoading: false
    });
  }

  // update query string as needed
  if (changed.queryParams) {
    this.fire('updateQueryString', current);
  }

};

function defaultDisplayOptionValue(p) {
  return displayOptions[p] && displayOptions[p].values[0];
}

function buildFeatureRows(obj, level = -1, prop = null, rows = []) {
  if (Array.isArray(obj)) {
    if (prop) {
      rows.push({ level, obj, prop }); // header row
    }
    obj.forEach((x, i) => buildFeatureRows(x, level + 1, prop, rows));
  } else if (typeof obj === 'object' && obj != null) {
    if (prop) {
      rows.push({ level, obj, prop }); // header row
    }
    for (var prop in obj) {
      buildFeatureRows(obj[prop], level + 1, prop, rows);
    }
  } else {
    rows.push({ level, obj, prop, value: obj });
  }
  return rows;
}

function hashString (string) {
    var hash = 0, i, chr, len;

    if (string.length === 0) {
        return hash;
    }

    for (i = 0, len = string.length; i < len; i++) {
        chr   = string.charCodeAt(i);
        hash  = ((hash << 5) - hash) + chr;
        hash |= 0; // Convert to 32bit integer
    }
    return hash;
}

	function add_css() {
		var style = createElement("style");
		style.id = 'svelte-3lp2tt-style';
		style.textContent = ".controls.svelte-3lp2tt{position:absolute;z-index:1000;min-height:100vh;max-height:100vh;display:flex;flex-direction:column}.panel.svelte-3lp2tt{margin:5px;padding:0.5em;background-color:rgba(200, 200, 200, 0.75);border:1px solid black;border-radius:3px;color:black;box-shadow:2px 2px 2px black}#controls_left.svelte-3lp2tt{width:300px}#space_info.svelte-3lp2tt{overflow-wrap:break-word}#properties.svelte-3lp2tt{overflow:auto;flex:1 1 0}#properties.svelte-3lp2tt table.svelte-3lp2tt{width:100%}#properties.svelte-3lp2tt tr.svelte-3lp2tt:hover{background-color:rgba(240, 240, 240, 0.75)}#properties.svelte-3lp2tt tr.active.svelte-3lp2tt{background-color:rgba(175, 175, 175, 0.75)}#colors.svelte-3lp2tt{overflow:auto;flex:1 1 auto;height:20vh}#controls_right.svelte-3lp2tt{width:350px;right:0}#tag_panel.svelte-3lp2tt{overflow:auto;flex:1 1 auto}#tag_search.svelte-3lp2tt{width:305px;margin:4px 0px;padding:2px}.dot.svelte-3lp2tt{height:11px;width:11px;background-color:yellow;border:2px solid grey;border-radius:50%;display:inline-block;vertical-align:bottom}";
		append(document.head, style);
	}

	function get_each_context_4(ctx, list, i) {
		const child_ctx = Object.create(ctx);
		child_ctx.tag = list[i];
		return child_ctx;
	}

	function get_each_context_3(ctx, list, i) {
		const child_ctx = Object.create(ctx);
		child_ctx.value = list[i][0];
		child_ctx.count = list[i][1];
		return child_ctx;
	}

	function get_each_context_2(ctx, list, i) {
		const child_ctx = Object.create(ctx);
		child_ctx.palette = list[i];
		return child_ctx;
	}

	function get_each_context_1(ctx, list, i) {
		const child_ctx = Object.create(ctx);
		child_ctx.mode = list[i];
		return child_ctx;
	}

	function click_handler(event) {
		const { component, ctx } = this._svelte;

		component.setFeatureProp(ctx.r.prop);
	}

	function get_each_context(ctx, list, i) {
		const child_ctx = Object.create(ctx);
		child_ctx.r = list[i];
		return child_ctx;
	}

	function create_main_fragment(component, ctx) {
		var div3, div0, p0, text0, p1, text1, div1, text2, div2, p2, text3, text4, table0, text5, div8, div4, table1, text6, text7, tr0, td0, td1, text9_value = ctx.uniqueTagsInViewport.size, text9, text10, tr1, td2, td3, text12_value = ctx.uniqueTagsSeen.size, text12, text13, p3, text14, br0, text15, text16, p4, text18, p5, input0, text19, input1, text20, br1, text21, p6, text22, div7, span0, text23, span1, text24, span2, text25, text26, text27, text28, div6, div5, input2, input2_updating = false, text29, each_blocks_1 = [], each_lookup = blankObject(), text30;

		function onwindowkeydown(event) {
			component.handleKeyPress(event);;
		}
		window.addEventListener("keydown", onwindowkeydown);

		function select_block_type(ctx) {
			if (ctx.spaceInfo) return create_if_block_14;
			if (!ctx.spaceLoading) return create_if_block_15;
		}

		var current_block_type = select_block_type(ctx);
		var if_block0 = current_block_type && current_block_type(component, ctx);

		var if_block1 = (ctx.displayToggles) && create_if_block_13(component, ctx);

		function select_block_type_1(ctx) {
			if (ctx.feature) return create_if_block_12;
			return create_else_block_5;
		}

		var current_block_type_1 = select_block_type_1(ctx);
		var if_block2 = current_block_type_1(component, ctx);

		var if_block3 = (ctx.displayToggles) && create_if_block_10(component, ctx);

		function select_block_type_2(ctx) {
			if (ctx.featureProp && ctx.featurePropCount != null) return create_if_block_8;
			return create_else_block_4;
		}

		var current_block_type_2 = select_block_type_2(ctx);
		var if_block4 = current_block_type_2(component, ctx);

		var if_block5 = (ctx.featureProp && ctx.featurePropValueCounts) && create_if_block_6(component, ctx);

		var if_block6 = (ctx.numFeaturesInViewport) && create_if_block_5(component, ctx);

		var if_block7 = (ctx.numFeatureTagsInViewport != null) && create_if_block_4(component, ctx);

		function select_block_type_4(ctx) {
			if (ctx.tagFilterList.length > 0) return create_if_block_3;
			return create_else_block_2;
		}

		var current_block_type_3 = select_block_type_4(ctx);
		var if_block8 = current_block_type_3(component, ctx);

		function click_handler_1(event) {
			component.set({ tagFilterList: [] });
		}

		function input0_change_handler() {
			component.set({ tagFilterAndOr: input0.__value });
		}

		function input1_change_handler() {
			component.set({ tagFilterAndOr: input1.__value });
		}

		function select_block_type_5(ctx) {
			if (ctx.tagFilterViewport) return create_if_block_2;
			return create_else_block_1;
		}

		var current_block_type_4 = select_block_type_5(ctx);
		var if_block9 = current_block_type_4(component, ctx);

		function click_handler_2(event) {
			component.toggleTagFilterViewport();
		}

		function select_block_type_6(ctx) {
			if (ctx.tagFilterAt) return create_if_block_1;
			return create_else_block;
		}

		var current_block_type_5 = select_block_type_6(ctx);
		var if_block10 = current_block_type_5(component, ctx);

		function click_handler_3(event) {
			component.toggleTagFilterAt();
		}

		function click_handler_4(event) {
			component.toggleTagSort();
		}

		function input2_input_handler() {
			input2_updating = true;
			component.set({ tagFilterSearch: input2.value });
			input2_updating = false;
		}

		function keydown_handler(event) {
			event.stopPropagation();
		}

		var each_value_4 = ctx.tagDisplayList.slice(0, 500);

		const get_key = ctx => ctx.JSON.stringify(ctx.tag);

		for (var i = 0; i < each_value_4.length; i += 1) {
			let child_ctx = get_each_context_4(ctx, each_value_4, i);
			let key = get_key(child_ctx);
			each_blocks_1[i] = each_lookup[key] = create_each_block(component, key, child_ctx);
		}

		var if_block11 = (ctx.tagDisplayList.length > 500) && create_if_block(component, ctx);

		return {
			c() {
				div3 = createElement("div");
				div0 = createElement("div");
				p0 = createElement("p");
				if (if_block0) if_block0.c();
				text0 = createText("\n    ");
				p1 = createElement("p");
				if (if_block1) if_block1.c();
				text1 = createText("\n  ");
				div1 = createElement("div");
				if_block2.c();
				text2 = createText("\n\n  ");
				div2 = createElement("div");
				p2 = createElement("p");
				if (if_block3) if_block3.c();
				text3 = createText("\n\n      ");
				if_block4.c();
				text4 = createText("\n\n    ");
				table0 = createElement("table");
				if (if_block5) if_block5.c();
				text5 = createText("\n\n");
				div8 = createElement("div");
				div4 = createElement("div");
				table1 = createElement("table");
				if (if_block6) if_block6.c();
				text6 = createText("\n      ");
				if (if_block7) if_block7.c();
				text7 = createText("\n      ");
				tr0 = createElement("tr");
				td0 = createElement("td");
				td0.textContent = "unique tags in viewport";
				td1 = createElement("td");
				text9 = createText(text9_value);
				text10 = createText("\n      ");
				tr1 = createElement("tr");
				td2 = createElement("td");
				td2.textContent = "unique tags seen";
				td3 = createElement("td");
				text12 = createText(text12_value);
				text13 = createText("\n    ");
				p3 = createElement("p");
				text14 = createText("filtering by tags:");
				br0 = createElement("br");
				text15 = createText("\n      ");
				if_block8.c();
				text16 = createText("\n    ");
				p4 = createElement("p");
				p4.textContent = "CLEAR TAG FILTERS";
				text18 = createText("\n    ");
				p5 = createElement("p");
				input0 = createElement("input");
				text19 = createText("or\n      ");
				input1 = createElement("input");
				text20 = createText("and");
				br1 = createElement("br");
				text21 = createText("\n    ");
				p6 = createElement("p");
				text22 = createText("\n  ");
				div7 = createElement("div");
				span0 = createElement("span");
				if_block9.c();
				text23 = createText("\n    ");
				span1 = createElement("span");
				if_block10.c();
				text24 = createText("\n    ");
				span2 = createElement("span");
				text25 = createText("[sort by ");
				text26 = createText(ctx.nextTagSort);
				text27 = createText("]");
				text28 = createText("\n    ");
				div6 = createElement("div");
				div5 = createElement("div");
				input2 = createElement("input");
				text29 = createText("\n\n      \n      ");

				for (i = 0; i < each_blocks_1.length; i += 1) each_blocks_1[i].c();

				text30 = createText("\n\n      ");
				if (if_block11) if_block11.c();
				p0.id = "space_info";
				p0.className = "svelte-3lp2tt";
				p1.id = "style_info";
				div0.id = "spaces";
				div0.className = "panel svelte-3lp2tt";
				div1.id = "properties";
				div1.className = "panel svelte-3lp2tt";
				p2.id = "colorProperties";
				table0.id = "prop_stats";
				div2.id = "colors";
				div2.className = "panel svelte-3lp2tt";
				div3.id = "controls_left";
				div3.className = "controls svelte-3lp2tt";
				table1.id = "tag_stats";
				p3.id = "tags_filtered";
				addListener(p4, "click", click_handler_1);
				setStyle(p4, "color", "blue");
				p4.id = "clear_filters";
				component._bindingGroups[0].push(input0);
				addListener(input0, "change", input0_change_handler);
				setAttribute(input0, "type", "radio");
				setAttribute(input0, "g", "and_or");
				input0.__value = "or";
				input0.value = input0.__value;
				component._bindingGroups[0].push(input1);
				addListener(input1, "change", input1_change_handler);
				setAttribute(input1, "type", "radio");
				input1.name = "and_or";
				input1.__value = "and";
				input1.value = input1.__value;
				p5.id = "and_or";
				div4.id = "tag_summary";
				div4.className = "panel svelte-3lp2tt";
				addListener(span0, "click", click_handler_2);
				setStyle(span0, "color", "blue");
				addListener(span1, "click", click_handler_3);
				setStyle(span1, "color", "blue");
				addListener(span2, "click", click_handler_4);
				setStyle(span2, "color", "blue");
				addListener(input2, "input", input2_input_handler);
				addListener(input2, "keydown", keydown_handler);
				input2.id = "tag_search";
				setAttribute(input2, "type", "text");
				input2.placeholder = "Filter tags";
				input2.className = "svelte-3lp2tt";
				div6.id = "tags";
				div7.id = "tag_panel";
				div7.className = "panel svelte-3lp2tt";
				div8.id = "controls_right";
				div8.className = "controls svelte-3lp2tt";
			},

			m(target, anchor) {
				insert(target, div3, anchor);
				append(div3, div0);
				append(div0, p0);
				if (if_block0) if_block0.m(p0, null);
				append(div0, text0);
				append(div0, p1);
				if (if_block1) if_block1.m(p1, null);
				append(div3, text1);
				append(div3, div1);
				if_block2.m(div1, null);
				append(div3, text2);
				append(div3, div2);
				append(div2, p2);
				if (if_block3) if_block3.m(p2, null);
				append(p2, text3);
				if_block4.m(p2, null);
				append(div2, text4);
				append(div2, table0);
				if (if_block5) if_block5.m(table0, null);
				insert(target, text5, anchor);
				insert(target, div8, anchor);
				append(div8, div4);
				append(div4, table1);
				if (if_block6) if_block6.m(table1, null);
				append(table1, text6);
				if (if_block7) if_block7.m(table1, null);
				append(table1, text7);
				append(table1, tr0);
				append(tr0, td0);
				append(tr0, td1);
				append(td1, text9);
				append(table1, text10);
				append(table1, tr1);
				append(tr1, td2);
				append(tr1, td3);
				append(td3, text12);
				append(div4, text13);
				append(div4, p3);
				append(p3, text14);
				append(p3, br0);
				append(p3, text15);
				if_block8.m(p3, null);
				append(div4, text16);
				append(div4, p4);
				append(div4, text18);
				append(div4, p5);
				append(p5, input0);

				input0.checked = input0.__value === ctx.tagFilterAndOr;

				append(p5, text19);
				append(p5, input1);

				input1.checked = input1.__value === ctx.tagFilterAndOr;

				append(p5, text20);
				append(p5, br1);
				append(p5, text21);
				append(div4, p6);
				append(div8, text22);
				append(div8, div7);
				append(div7, span0);
				if_block9.m(span0, null);
				append(div7, text23);
				append(div7, span1);
				if_block10.m(span1, null);
				append(div7, text24);
				append(div7, span2);
				append(span2, text25);
				append(span2, text26);
				append(span2, text27);
				append(div7, text28);
				append(div7, div6);
				append(div6, div5);
				append(div5, input2);

				input2.value = ctx.tagFilterSearch;

				append(div6, text29);

				for (i = 0; i < each_blocks_1.length; i += 1) each_blocks_1[i].m(div6, null);

				append(div6, text30);
				if (if_block11) if_block11.m(div6, null);
			},

			p(changed, ctx) {
				if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block0) {
					if_block0.p(changed, ctx);
				} else {
					if (if_block0) if_block0.d(1);
					if_block0 = current_block_type && current_block_type(component, ctx);
					if (if_block0) if_block0.c();
					if (if_block0) if_block0.m(p0, null);
				}

				if (ctx.displayToggles) {
					if (if_block1) {
						if_block1.p(changed, ctx);
					} else {
						if_block1 = create_if_block_13(component, ctx);
						if_block1.c();
						if_block1.m(p1, null);
					}
				} else if (if_block1) {
					if_block1.d(1);
					if_block1 = null;
				}

				if (current_block_type_1 === (current_block_type_1 = select_block_type_1(ctx)) && if_block2) {
					if_block2.p(changed, ctx);
				} else {
					if_block2.d(1);
					if_block2 = current_block_type_1(component, ctx);
					if_block2.c();
					if_block2.m(div1, null);
				}

				if (ctx.displayToggles) {
					if (if_block3) {
						if_block3.p(changed, ctx);
					} else {
						if_block3 = create_if_block_10(component, ctx);
						if_block3.c();
						if_block3.m(p2, text3);
					}
				} else if (if_block3) {
					if_block3.d(1);
					if_block3 = null;
				}

				if (current_block_type_2 === (current_block_type_2 = select_block_type_2(ctx)) && if_block4) {
					if_block4.p(changed, ctx);
				} else {
					if_block4.d(1);
					if_block4 = current_block_type_2(component, ctx);
					if_block4.c();
					if_block4.m(p2, null);
				}

				if (ctx.featureProp && ctx.featurePropValueCounts) {
					if (if_block5) {
						if_block5.p(changed, ctx);
					} else {
						if_block5 = create_if_block_6(component, ctx);
						if_block5.c();
						if_block5.m(table0, null);
					}
				} else if (if_block5) {
					if_block5.d(1);
					if_block5 = null;
				}

				if (ctx.numFeaturesInViewport) {
					if (if_block6) {
						if_block6.p(changed, ctx);
					} else {
						if_block6 = create_if_block_5(component, ctx);
						if_block6.c();
						if_block6.m(table1, text6);
					}
				} else if (if_block6) {
					if_block6.d(1);
					if_block6 = null;
				}

				if (ctx.numFeatureTagsInViewport != null) {
					if (if_block7) {
						if_block7.p(changed, ctx);
					} else {
						if_block7 = create_if_block_4(component, ctx);
						if_block7.c();
						if_block7.m(table1, text7);
					}
				} else if (if_block7) {
					if_block7.d(1);
					if_block7 = null;
				}

				if ((changed.uniqueTagsInViewport) && text9_value !== (text9_value = ctx.uniqueTagsInViewport.size)) {
					setData(text9, text9_value);
				}

				if ((changed.uniqueTagsSeen) && text12_value !== (text12_value = ctx.uniqueTagsSeen.size)) {
					setData(text12, text12_value);
				}

				if (current_block_type_3 === (current_block_type_3 = select_block_type_4(ctx)) && if_block8) {
					if_block8.p(changed, ctx);
				} else {
					if_block8.d(1);
					if_block8 = current_block_type_3(component, ctx);
					if_block8.c();
					if_block8.m(p3, null);
				}

				if (changed.tagFilterAndOr) input0.checked = input0.__value === ctx.tagFilterAndOr;
				if (changed.tagFilterAndOr) input1.checked = input1.__value === ctx.tagFilterAndOr;

				if (current_block_type_4 !== (current_block_type_4 = select_block_type_5(ctx))) {
					if_block9.d(1);
					if_block9 = current_block_type_4(component, ctx);
					if_block9.c();
					if_block9.m(span0, null);
				}

				if (current_block_type_5 !== (current_block_type_5 = select_block_type_6(ctx))) {
					if_block10.d(1);
					if_block10 = current_block_type_5(component, ctx);
					if_block10.c();
					if_block10.m(span1, null);
				}

				if (changed.nextTagSort) {
					setData(text26, ctx.nextTagSort);
				}

				if (!input2_updating && changed.tagFilterSearch) input2.value = ctx.tagFilterSearch;

				const each_value_4 = ctx.tagDisplayList.slice(0, 500);
				each_blocks_1 = updateKeyedEach(each_blocks_1, component, changed, get_key, 1, ctx, each_value_4, each_lookup, div6, destroyBlock, create_each_block, "m", text30, get_each_context_4);

				if (ctx.tagDisplayList.length > 500) {
					if (if_block11) {
						if_block11.p(changed, ctx);
					} else {
						if_block11 = create_if_block(component, ctx);
						if_block11.c();
						if_block11.m(div6, null);
					}
				} else if (if_block11) {
					if_block11.d(1);
					if_block11 = null;
				}
			},

			d(detach) {
				window.removeEventListener("keydown", onwindowkeydown);

				if (detach) {
					detachNode(div3);
				}

				if (if_block0) if_block0.d();
				if (if_block1) if_block1.d();
				if_block2.d();
				if (if_block3) if_block3.d();
				if_block4.d();
				if (if_block5) if_block5.d();
				if (detach) {
					detachNode(text5);
					detachNode(div8);
				}

				if (if_block6) if_block6.d();
				if (if_block7) if_block7.d();
				if_block8.d();
				removeListener(p4, "click", click_handler_1);
				component._bindingGroups[0].splice(component._bindingGroups[0].indexOf(input0), 1);
				removeListener(input0, "change", input0_change_handler);
				component._bindingGroups[0].splice(component._bindingGroups[0].indexOf(input1), 1);
				removeListener(input1, "change", input1_change_handler);
				if_block9.d();
				removeListener(span0, "click", click_handler_2);
				if_block10.d();
				removeListener(span1, "click", click_handler_3);
				removeListener(span2, "click", click_handler_4);
				removeListener(input2, "input", input2_input_handler);
				removeListener(input2, "keydown", keydown_handler);

				for (i = 0; i < each_blocks_1.length; i += 1) each_blocks_1[i].d();

				if (if_block11) if_block11.d();
			}
		};
	}

	// (10:29) 
	function create_if_block_15(component, ctx) {
		var input0, input0_updating = false, text0, input1, input1_updating = false, text1, button;

		function input0_input_handler() {
			input0_updating = true;
			component.set({ spaceId: input0.value });
			input0_updating = false;
		}

		function input1_input_handler() {
			input1_updating = true;
			component.set({ token: input1.value });
			input1_updating = false;
		}

		function click_handler(event) {
			component.updateSpace(true);
		}

		return {
			c() {
				input0 = createElement("input");
				text0 = createText("\n        ");
				input1 = createElement("input");
				text1 = createText("\n        ");
				button = createElement("button");
				button.textContent = "Show XYZ Space";
				addListener(input0, "input", input0_input_handler);
				setAttribute(input0, "type", "text");
				input0.placeholder = "enter an XYZ space ID";
				addListener(input1, "input", input1_input_handler);
				setAttribute(input1, "type", "text");
				input1.placeholder = "enter an XYZ token";
				addListener(button, "click", click_handler);
			},

			m(target, anchor) {
				insert(target, input0, anchor);

				input0.value = ctx.spaceId;

				insert(target, text0, anchor);
				insert(target, input1, anchor);

				input1.value = ctx.token;

				insert(target, text1, anchor);
				insert(target, button, anchor);
			},

			p(changed, ctx) {
				if (!input0_updating && changed.spaceId) input0.value = ctx.spaceId;
				if (!input1_updating && changed.token) input1.value = ctx.token;
			},

			d(detach) {
				if (detach) {
					detachNode(input0);
				}

				removeListener(input0, "input", input0_input_handler);
				if (detach) {
					detachNode(text0);
					detachNode(input1);
				}

				removeListener(input1, "input", input1_input_handler);
				if (detach) {
					detachNode(text1);
					detachNode(button);
				}

				removeListener(button, "click", click_handler);
			}
		};
	}

	// (6:6) {#if spaceInfo}
	function create_if_block_14(component, ctx) {
		var text0, text1, text2_value = ctx.spaceInfo.title, text2, br0, text3, text4_value = ctx.spaceInfo.numFeatures.toLocaleString(), text4, text5, text6_value = ctx.spaceInfo.dataSize, text6, br1, text7, text8_value = ctx.spaceInfo.description, text8;

		return {
			c() {
				text0 = createText(ctx.spaceId);
				text1 = createText(": ");
				text2 = createText(text2_value);
				br0 = createElement("br");
				text3 = createText("\n        ");
				text4 = createText(text4_value);
				text5 = createText(" features, ");
				text6 = createText(text6_value);
				br1 = createElement("br");
				text7 = createText("\n        ");
				text8 = createText(text8_value);
			},

			m(target, anchor) {
				insert(target, text0, anchor);
				insert(target, text1, anchor);
				insert(target, text2, anchor);
				insert(target, br0, anchor);
				insert(target, text3, anchor);
				insert(target, text4, anchor);
				insert(target, text5, anchor);
				insert(target, text6, anchor);
				insert(target, br1, anchor);
				insert(target, text7, anchor);
				insert(target, text8, anchor);
			},

			p(changed, ctx) {
				if (changed.spaceId) {
					setData(text0, ctx.spaceId);
				}

				if ((changed.spaceInfo) && text2_value !== (text2_value = ctx.spaceInfo.title)) {
					setData(text2, text2_value);
				}

				if ((changed.spaceInfo) && text4_value !== (text4_value = ctx.spaceInfo.numFeatures.toLocaleString())) {
					setData(text4, text4_value);
				}

				if ((changed.spaceInfo) && text6_value !== (text6_value = ctx.spaceInfo.dataSize)) {
					setData(text6, text6_value);
				}

				if ((changed.spaceInfo) && text8_value !== (text8_value = ctx.spaceInfo.description)) {
					setData(text8, text8_value);
				}
			},

			d(detach) {
				if (detach) {
					detachNode(text0);
					detachNode(text1);
					detachNode(text2);
					detachNode(br0);
					detachNode(text3);
					detachNode(text4);
					detachNode(text5);
					detachNode(text6);
					detachNode(br1);
					detachNode(text7);
					detachNode(text8);
				}
			}
		};
	}

	// (17:6) {#if displayToggles}
	function create_if_block_13(component, ctx) {
		var table, tr0, td0, text1, td1, text2_value = ctx.displayToggles.roads, text2, text3, td2, text5, td3, text6_value = ctx.displayToggles.buildings, text6, text7, td4, text9, td5, text10_value = ctx.displayToggles.water, text10, text11, tr1, td6, text13, td7, text14_value = ctx.displayToggles.points, text14, text15, td8, text17, td9, text18_value = ctx.displayToggles.lines, text18, text19, td10, text21, td11, text22_value = ctx.displayToggles.outlines, text22, text23, tr2, td12, text25, td13, text26, text27, td14, text29, td15, text30_value = ctx.displayToggles.colors, text30;

		function click_handler(event) {
			component.toggleDisplayOption("roads");
		}

		function click_handler_1(event) {
			component.toggleDisplayOption("buildings");
		}

		function click_handler_2(event) {
			component.toggleDisplayOption("water");
		}

		function click_handler_3(event) {
			component.toggleDisplayOption("points");
		}

		function click_handler_4(event) {
			component.toggleDisplayOption("lines");
		}

		function click_handler_5(event) {
			component.toggleDisplayOption("outlines");
		}

		function click_handler_6(event) {
			component.toggleBasemap();
		}

		function click_handler_7(event) {
			component.toggleDisplayOption("colors");
		}

		return {
			c() {
				table = createElement("table");
				tr0 = createElement("tr");
				td0 = createElement("td");
				td0.textContent = "roads:";
				text1 = createText("\n            ");
				td1 = createElement("td");
				text2 = createText(text2_value);
				text3 = createText("\n            ");
				td2 = createElement("td");
				td2.textContent = "buildings:";
				text5 = createText("\n            ");
				td3 = createElement("td");
				text6 = createText(text6_value);
				text7 = createText("\n            ");
				td4 = createElement("td");
				td4.textContent = "water:";
				text9 = createText("\n            ");
				td5 = createElement("td");
				text10 = createText(text10_value);
				text11 = createText("\n          ");
				tr1 = createElement("tr");
				td6 = createElement("td");
				td6.textContent = "points:";
				text13 = createText("\n            ");
				td7 = createElement("td");
				text14 = createText(text14_value);
				text15 = createText("\n            ");
				td8 = createElement("td");
				td8.textContent = "lines:";
				text17 = createText("\n            ");
				td9 = createElement("td");
				text18 = createText(text18_value);
				text19 = createText("\n            ");
				td10 = createElement("td");
				td10.textContent = "outlines:";
				text21 = createText("\n            ");
				td11 = createElement("td");
				text22 = createText(text22_value);
				text23 = createText("\n          ");
				tr2 = createElement("tr");
				td12 = createElement("td");
				td12.textContent = "basemap:";
				text25 = createText("\n            ");
				td13 = createElement("td");
				text26 = createText(ctx.basemap);
				text27 = createText("\n            ");
				td14 = createElement("td");
				td14.textContent = "colors:";
				text29 = createText("\n            ");
				td15 = createElement("td");
				text30 = createText(text30_value);
				addListener(td0, "click", click_handler);
				addListener(td2, "click", click_handler_1);
				addListener(td4, "click", click_handler_2);
				addListener(td6, "click", click_handler_3);
				addListener(td8, "click", click_handler_4);
				addListener(td10, "click", click_handler_5);
				addListener(td12, "click", click_handler_6);
				addListener(td14, "click", click_handler_7);
			},

			m(target, anchor) {
				insert(target, table, anchor);
				append(table, tr0);
				append(tr0, td0);
				append(tr0, text1);
				append(tr0, td1);
				append(td1, text2);
				append(tr0, text3);
				append(tr0, td2);
				append(tr0, text5);
				append(tr0, td3);
				append(td3, text6);
				append(tr0, text7);
				append(tr0, td4);
				append(tr0, text9);
				append(tr0, td5);
				append(td5, text10);
				append(table, text11);
				append(table, tr1);
				append(tr1, td6);
				append(tr1, text13);
				append(tr1, td7);
				append(td7, text14);
				append(tr1, text15);
				append(tr1, td8);
				append(tr1, text17);
				append(tr1, td9);
				append(td9, text18);
				append(tr1, text19);
				append(tr1, td10);
				append(tr1, text21);
				append(tr1, td11);
				append(td11, text22);
				append(table, text23);
				append(table, tr2);
				append(tr2, td12);
				append(tr2, text25);
				append(tr2, td13);
				append(td13, text26);
				append(tr2, text27);
				append(tr2, td14);
				append(tr2, text29);
				append(tr2, td15);
				append(td15, text30);
			},

			p(changed, ctx) {
				if ((changed.displayToggles) && text2_value !== (text2_value = ctx.displayToggles.roads)) {
					setData(text2, text2_value);
				}

				if ((changed.displayToggles) && text6_value !== (text6_value = ctx.displayToggles.buildings)) {
					setData(text6, text6_value);
				}

				if ((changed.displayToggles) && text10_value !== (text10_value = ctx.displayToggles.water)) {
					setData(text10, text10_value);
				}

				if ((changed.displayToggles) && text14_value !== (text14_value = ctx.displayToggles.points)) {
					setData(text14, text14_value);
				}

				if ((changed.displayToggles) && text18_value !== (text18_value = ctx.displayToggles.lines)) {
					setData(text18, text18_value);
				}

				if ((changed.displayToggles) && text22_value !== (text22_value = ctx.displayToggles.outlines)) {
					setData(text22, text22_value);
				}

				if (changed.basemap) {
					setData(text26, ctx.basemap);
				}

				if ((changed.displayToggles) && text30_value !== (text30_value = ctx.displayToggles.colors)) {
					setData(text30, text30_value);
				}
			},

			d(detach) {
				if (detach) {
					detachNode(table);
				}

				removeListener(td0, "click", click_handler);
				removeListener(td2, "click", click_handler_1);
				removeListener(td4, "click", click_handler_2);
				removeListener(td6, "click", click_handler_3);
				removeListener(td8, "click", click_handler_4);
				removeListener(td10, "click", click_handler_5);
				removeListener(td12, "click", click_handler_6);
				removeListener(td14, "click", click_handler_7);
			}
		};
	}

	// (57:4) {:else}
	function create_else_block_5(component, ctx) {
		var text0, br, text1;

		return {
			c() {
				text0 = createText("Interact with map to see properties.");
				br = createElement("br");
				text1 = createText("Click on a property value to generate unique colors.");
			},

			m(target, anchor) {
				insert(target, text0, anchor);
				insert(target, br, anchor);
				insert(target, text1, anchor);
			},

			p: noop,

			d(detach) {
				if (detach) {
					detachNode(text0);
					detachNode(br);
					detachNode(text1);
				}
			}
		};
	}

	// (46:4) {#if feature}
	function create_if_block_12(component, ctx) {
		var table;

		var each_value = ctx.featurePropRows;

		var each_blocks = [];

		for (var i = 0; i < each_value.length; i += 1) {
			each_blocks[i] = create_each_block_4(component, get_each_context(ctx, each_value, i));
		}

		return {
			c() {
				table = createElement("table");

				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}
				table.className = "svelte-3lp2tt";
			},

			m(target, anchor) {
				insert(target, table, anchor);

				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].m(table, null);
				}
			},

			p(changed, ctx) {
				if (changed.featurePropRows || changed.featureProp) {
					each_value = ctx.featurePropRows;

					for (var i = 0; i < each_value.length; i += 1) {
						const child_ctx = get_each_context(ctx, each_value, i);

						if (each_blocks[i]) {
							each_blocks[i].p(changed, child_ctx);
						} else {
							each_blocks[i] = create_each_block_4(component, child_ctx);
							each_blocks[i].c();
							each_blocks[i].m(table, null);
						}
					}

					for (; i < each_blocks.length; i += 1) {
						each_blocks[i].d(1);
					}
					each_blocks.length = each_value.length;
				}
			},

			d(detach) {
				if (detach) {
					detachNode(table);
				}

				destroyEach(each_blocks, detach);
			}
		};
	}

	// (48:8) {#each featurePropRows as r}
	function create_each_block_4(component, ctx) {
		var tr, td, raw_value = formatFeatureRow(ctx.r);

		return {
			c() {
				tr = createElement("tr");
				td = createElement("td");
				tr._svelte = { component, ctx };

				addListener(tr, "click", click_handler);
				tr.className = "svelte-3lp2tt";
				toggleClass(tr, "active", ctx.r.prop === ctx.featureProp);
			},

			m(target, anchor) {
				insert(target, tr, anchor);
				append(tr, td);
				td.innerHTML = raw_value;
			},

			p(changed, _ctx) {
				ctx = _ctx;
				if ((changed.featurePropRows) && raw_value !== (raw_value = formatFeatureRow(ctx.r))) {
					td.innerHTML = raw_value;
				}

				tr._svelte.ctx = ctx;
				if ((changed.featurePropRows || changed.featureProp)) {
					toggleClass(tr, "active", ctx.r.prop === ctx.featureProp);
				}
			},

			d(detach) {
				if (detach) {
					detachNode(tr);
				}

				removeListener(tr, "click", click_handler);
			}
		};
	}

	// (64:6) {#if displayToggles}
	function create_if_block_10(component, ctx) {
		var div, span, select, select_updating = false, text;

		var each_value_1 = ctx.colorModes;

		var each_blocks = [];

		for (var i = 0; i < each_value_1.length; i += 1) {
			each_blocks[i] = create_each_block_3(component, get_each_context_1(ctx, each_value_1, i));
		}

		function select_change_handler() {
			select_updating = true;
			ctx.displayToggles.colors = selectValue(select)
			component.set({ displayToggles: ctx.displayToggles, colorModes: ctx.colorModes });
			select_updating = false;
		}

		var if_block = (showFeaturePropPalette(ctx.displayToggles.colors)) && create_if_block_11(component, ctx);

		return {
			c() {
				div = createElement("div");
				span = createElement("span");
				select = createElement("select");

				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				text = createText("\n\n          ");
				if (if_block) if_block.c();
				addListener(select, "change", select_change_handler);
				if (!('displayToggles' in ctx)) component.root._beforecreate.push(select_change_handler);
			},

			m(target, anchor) {
				insert(target, div, anchor);
				append(div, span);
				append(span, select);

				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].m(select, null);
				}

				selectOption(select, ctx.displayToggles.colors)

				append(div, text);
				if (if_block) if_block.m(div, null);
			},

			p(changed, _ctx) {
				ctx = _ctx;
				if (changed.colorModes) {
					each_value_1 = ctx.colorModes;

					for (var i = 0; i < each_value_1.length; i += 1) {
						const child_ctx = get_each_context_1(ctx, each_value_1, i);

						if (each_blocks[i]) {
							each_blocks[i].p(changed, child_ctx);
						} else {
							each_blocks[i] = create_each_block_3(component, child_ctx);
							each_blocks[i].c();
							each_blocks[i].m(select, null);
						}
					}

					for (; i < each_blocks.length; i += 1) {
						each_blocks[i].d(1);
					}
					each_blocks.length = each_value_1.length;
				}

				if (!select_updating && changed.displayToggles) selectOption(select, ctx.displayToggles.colors)

				if (showFeaturePropPalette(ctx.displayToggles.colors)) {
					if (if_block) {
						if_block.p(changed, ctx);
					} else {
						if_block = create_if_block_11(component, ctx);
						if_block.c();
						if_block.m(div, null);
					}
				} else if (if_block) {
					if_block.d(1);
					if_block = null;
				}
			},

			d(detach) {
				if (detach) {
					detachNode(div);
				}

				destroyEach(each_blocks, detach);

				removeListener(select, "change", select_change_handler);
				if (if_block) if_block.d();
			}
		};
	}

	// (68:14) {#each colorModes as mode}
	function create_each_block_3(component, ctx) {
		var option, text_value = ctx.mode, text, option_value_value;

		return {
			c() {
				option = createElement("option");
				text = createText(text_value);
				option.__value = option_value_value = ctx.mode;
				option.value = option.__value;
			},

			m(target, anchor) {
				insert(target, option, anchor);
				append(option, text);
			},

			p(changed, ctx) {
				if ((changed.colorModes) && text_value !== (text_value = ctx.mode)) {
					setData(text, text_value);
				}

				if ((changed.colorModes) && option_value_value !== (option_value_value = ctx.mode)) {
					option.__value = option_value_value;
				}

				option.value = option.__value;
			},

			d(detach) {
				if (detach) {
					detachNode(option);
				}
			}
		};
	}

	// (74:10) {#if showFeaturePropPalette(displayToggles.colors)}
	function create_if_block_11(component, ctx) {
		var span, select, select_updating = false, text0, label, input, text1;

		var each_value_2 = ctx.Object.keys(ctx.colorPalettes);

		var each_blocks = [];

		for (var i = 0; i < each_value_2.length; i += 1) {
			each_blocks[i] = create_each_block_2(component, get_each_context_2(ctx, each_value_2, i));
		}

		function select_change_handler() {
			select_updating = true;
			component.set({ featurePropPaletteName: selectValue(select) });
			select_updating = false;
		}

		function input_change_handler() {
			component.set({ featurePropPaletteFlip: input.checked });
		}

		return {
			c() {
				span = createElement("span");
				select = createElement("select");

				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				text0 = createText("\n\n            ");
				label = createElement("label");
				input = createElement("input");
				text1 = createText("\n              Flip");
				addListener(select, "change", select_change_handler);
				if (!('featurePropPaletteName' in ctx)) component.root._beforecreate.push(select_change_handler);
				addListener(input, "change", input_change_handler);
				setAttribute(input, "type", "checkbox");
			},

			m(target, anchor) {
				insert(target, span, anchor);
				append(span, select);

				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].m(select, null);
				}

				selectOption(select, ctx.featurePropPaletteName)

				insert(target, text0, anchor);
				insert(target, label, anchor);
				append(label, input);

				input.checked = ctx.featurePropPaletteFlip;

				append(label, text1);
			},

			p(changed, ctx) {
				if (changed.Object || changed.colorPalettes) {
					each_value_2 = ctx.Object.keys(ctx.colorPalettes);

					for (var i = 0; i < each_value_2.length; i += 1) {
						const child_ctx = get_each_context_2(ctx, each_value_2, i);

						if (each_blocks[i]) {
							each_blocks[i].p(changed, child_ctx);
						} else {
							each_blocks[i] = create_each_block_2(component, child_ctx);
							each_blocks[i].c();
							each_blocks[i].m(select, null);
						}
					}

					for (; i < each_blocks.length; i += 1) {
						each_blocks[i].d(1);
					}
					each_blocks.length = each_value_2.length;
				}

				if (!select_updating && changed.featurePropPaletteName) selectOption(select, ctx.featurePropPaletteName)
				if (changed.featurePropPaletteFlip) input.checked = ctx.featurePropPaletteFlip;
			},

			d(detach) {
				if (detach) {
					detachNode(span);
				}

				destroyEach(each_blocks, detach);

				removeListener(select, "change", select_change_handler);
				if (detach) {
					detachNode(text0);
					detachNode(label);
				}

				removeListener(input, "change", input_change_handler);
			}
		};
	}

	// (77:16) {#each Object.keys(colorPalettes) as palette}
	function create_each_block_2(component, ctx) {
		var option, text_value = ctx.palette, text, option_value_value;

		return {
			c() {
				option = createElement("option");
				text = createText(text_value);
				option.__value = option_value_value = ctx.palette;
				option.value = option.__value;
			},

			m(target, anchor) {
				insert(target, option, anchor);
				append(option, text);
			},

			p(changed, ctx) {
				if ((changed.Object || changed.colorPalettes) && text_value !== (text_value = ctx.palette)) {
					setData(text, text_value);
				}

				if ((changed.Object || changed.colorPalettes) && option_value_value !== (option_value_value = ctx.palette)) {
					option.__value = option_value_value;
				}

				option.value = option.__value;
			},

			d(detach) {
				if (detach) {
					detachNode(option);
				}
			}
		};
	}

	// (112:6) {:else}
	function create_else_block_4(component, ctx) {
		var div;

		return {
			c() {
				div = createElement("div");
				div.textContent = "click on property value for unique colors";
				setStyle(div, "margin", "5px 0 5px 0");
			},

			m(target, anchor) {
				insert(target, div, anchor);
			},

			p: noop,

			d(detach) {
				if (detach) {
					detachNode(div);
				}
			}
		};
	}

	// (92:6) {#if featureProp && featurePropCount != null}
	function create_if_block_8(component, ctx) {
		var div0, text0, text1, i, text2, text3, br, text4, text5, div1, span0, text6, text7, text8, text9, span1;

		function select_block_type_3(ctx) {
			if (ctx.featurePropMin != null) return create_if_block_9;
			return create_else_block_3;
		}

		var current_block_type = select_block_type_3(ctx);
		var if_block = current_block_type(component, ctx);

		function click_handler_1(event) {
			component.toggleFeaturePropValueSort();
		}

		function click_handler_2(event) {
			component.set({ featureProp: null });
		}

		return {
			c() {
				div0 = createElement("div");
				text0 = createText(ctx.featurePropCount);
				text1 = createText(" unique values of ");
				i = createElement("i");
				text2 = createText(ctx.featureProp);
				text3 = createText(" in viewport");
				br = createElement("br");
				text4 = createText("\n          ");
				if_block.c();
				text5 = createText("\n\n        ");
				div1 = createElement("div");
				span0 = createElement("span");
				text6 = createText("[sort by ");
				text7 = createText(ctx.nextFeaturePropValueSort);
				text8 = createText("]");
				text9 = createText("\n          ");
				span1 = createElement("span");
				span1.textContent = "clear filter";
				setStyle(div0, "margin", "5px 0 5px 0");
				addListener(span0, "click", click_handler_1);
				setStyle(span0, "color", "blue");
				addListener(span1, "click", click_handler_2);
				setStyle(span1, "color", "blue");
				span1.id = "clear_color_properties";
			},

			m(target, anchor) {
				insert(target, div0, anchor);
				append(div0, text0);
				append(div0, text1);
				append(div0, i);
				append(i, text2);
				append(div0, text3);
				append(div0, br);
				append(div0, text4);
				if_block.m(div0, null);
				insert(target, text5, anchor);
				insert(target, div1, anchor);
				append(div1, span0);
				append(span0, text6);
				append(span0, text7);
				append(span0, text8);
				append(div1, text9);
				append(div1, span1);
			},

			p(changed, ctx) {
				if (changed.featurePropCount) {
					setData(text0, ctx.featurePropCount);
				}

				if (changed.featureProp) {
					setData(text2, ctx.featureProp);
				}

				if (current_block_type === (current_block_type = select_block_type_3(ctx)) && if_block) {
					if_block.p(changed, ctx);
				} else {
					if_block.d(1);
					if_block = current_block_type(component, ctx);
					if_block.c();
					if_block.m(div0, null);
				}

				if (changed.nextFeaturePropValueSort) {
					setData(text7, ctx.nextFeaturePropValueSort);
				}
			},

			d(detach) {
				if (detach) {
					detachNode(div0);
				}

				if_block.d();
				if (detach) {
					detachNode(text5);
					detachNode(div1);
				}

				removeListener(span0, "click", click_handler_1);
				removeListener(span1, "click", click_handler_2);
			}
		};
	}

	// (101:10) {:else}
	function create_else_block_3(component, ctx) {
		var text;

		return {
			c() {
				text = createText("no min/max (no numeric values found)");
			},

			m(target, anchor) {
				insert(target, text, anchor);
			},

			p: noop,

			d(detach) {
				if (detach) {
					detachNode(text);
				}
			}
		};
	}

	// (95:10) {#if featurePropMin != null}
	function create_if_block_9(component, ctx) {
		var text0, text1, text2, text3, text4, text5, br, text6, text7_value = ctx.featurePropMean.toFixed(2), text7, text8, text9_value = ctx.featurePropStdDev.toFixed(2), text9, text10, text11_value = ctx.featurePropSigma.toFixed(2), text11, text12, text13_value = ctx.featurePropSigmaFloor.toFixed(2), text13, text14, text15_value = ctx.featurePropSigmaCeiling.toFixed(2), text15, text16, pre, text17;

		return {
			c() {
				text0 = createText("min: ");
				text1 = createText(ctx.featurePropMin);
				text2 = createText(", median: ");
				text3 = createText(ctx.featurePropMedian);
				text4 = createText(", max: ");
				text5 = createText(ctx.featurePropMax);
				br = createElement("br");
				text6 = createText("\n            μ: ");
				text7 = createText(text7_value);
				text8 = createText(",\n            σ: ");
				text9 = createText(text9_value);
				text10 = createText(",\n            ");
				text11 = createText(text11_value);
				text12 = createText("% (");
				text13 = createText(text13_value);
				text14 = createText(" - ");
				text15 = createText(text15_value);
				text16 = createText(")\n            ");
				pre = createElement("pre");
				text17 = createText(ctx.featurePropHistogram);
			},

			m(target, anchor) {
				insert(target, text0, anchor);
				insert(target, text1, anchor);
				insert(target, text2, anchor);
				insert(target, text3, anchor);
				insert(target, text4, anchor);
				insert(target, text5, anchor);
				insert(target, br, anchor);
				insert(target, text6, anchor);
				insert(target, text7, anchor);
				insert(target, text8, anchor);
				insert(target, text9, anchor);
				insert(target, text10, anchor);
				insert(target, text11, anchor);
				insert(target, text12, anchor);
				insert(target, text13, anchor);
				insert(target, text14, anchor);
				insert(target, text15, anchor);
				insert(target, text16, anchor);
				insert(target, pre, anchor);
				append(pre, text17);
			},

			p(changed, ctx) {
				if (changed.featurePropMin) {
					setData(text1, ctx.featurePropMin);
				}

				if (changed.featurePropMedian) {
					setData(text3, ctx.featurePropMedian);
				}

				if (changed.featurePropMax) {
					setData(text5, ctx.featurePropMax);
				}

				if ((changed.featurePropMean) && text7_value !== (text7_value = ctx.featurePropMean.toFixed(2))) {
					setData(text7, text7_value);
				}

				if ((changed.featurePropStdDev) && text9_value !== (text9_value = ctx.featurePropStdDev.toFixed(2))) {
					setData(text9, text9_value);
				}

				if ((changed.featurePropSigma) && text11_value !== (text11_value = ctx.featurePropSigma.toFixed(2))) {
					setData(text11, text11_value);
				}

				if ((changed.featurePropSigmaFloor) && text13_value !== (text13_value = ctx.featurePropSigmaFloor.toFixed(2))) {
					setData(text13, text13_value);
				}

				if ((changed.featurePropSigmaCeiling) && text15_value !== (text15_value = ctx.featurePropSigmaCeiling.toFixed(2))) {
					setData(text15, text15_value);
				}

				if (changed.featurePropHistogram) {
					setData(text17, ctx.featurePropHistogram);
				}
			},

			d(detach) {
				if (detach) {
					detachNode(text0);
					detachNode(text1);
					detachNode(text2);
					detachNode(text3);
					detachNode(text4);
					detachNode(text5);
					detachNode(br);
					detachNode(text6);
					detachNode(text7);
					detachNode(text8);
					detachNode(text9);
					detachNode(text10);
					detachNode(text11);
					detachNode(text12);
					detachNode(text13);
					detachNode(text14);
					detachNode(text15);
					detachNode(text16);
					detachNode(pre);
				}
			}
		};
	}

	// (118:6) {#if featureProp && featurePropValueCounts}
	function create_if_block_6(component, ctx) {
		var thead, text_2, tbody;

		var each_value_3 = ctx.sortedFeaturePropValueCounts;

		var each_blocks = [];

		for (var i = 0; i < each_value_3.length; i += 1) {
			each_blocks[i] = create_each_block_1(component, get_each_context_3(ctx, each_value_3, i));
		}

		return {
			c() {
				thead = createElement("thead");
				thead.innerHTML = `<tr><td style="text-align: right;">#</td><td></td><td>Value</td></tr>`;
				text_2 = createText("\n        ");
				tbody = createElement("tbody");

				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}
			},

			m(target, anchor) {
				insert(target, thead, anchor);
				insert(target, text_2, anchor);
				insert(target, tbody, anchor);

				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].m(tbody, null);
				}
			},

			p(changed, ctx) {
				if (changed.sortedFeaturePropValueCounts || changed.displayToggles || changed.featureProp || changed.featurePropMin || changed.featurePropMax || changed.featurePropPalette || changed.featurePropPaletteFlip || changed.featurePropValueCounts || changed.colorHelpers) {
					each_value_3 = ctx.sortedFeaturePropValueCounts;

					for (var i = 0; i < each_value_3.length; i += 1) {
						const child_ctx = get_each_context_3(ctx, each_value_3, i);

						if (each_blocks[i]) {
							each_blocks[i].p(changed, child_ctx);
						} else {
							each_blocks[i] = create_each_block_1(component, child_ctx);
							each_blocks[i].c();
							each_blocks[i].m(tbody, null);
						}
					}

					for (; i < each_blocks.length; i += 1) {
						each_blocks[i].d(1);
					}
					each_blocks.length = each_value_3.length;
				}
			},

			d(detach) {
				if (detach) {
					detachNode(thead);
					detachNode(text_2);
					detachNode(tbody);
				}

				destroyEach(each_blocks, detach);
			}
		};
	}

	// (128:16) {#if showFeaturePropColorSwatch(displayToggles.colors)}
	function create_if_block_7(component, ctx) {
		var span;

		return {
			c() {
				span = createElement("span");
				span.className = "dot svelte-3lp2tt";
				setStyle(span, "background-color", formatFeaturePropValueColor(
                      // NOTE: seems there's no way to pass the whole svelte state here,
                      // so we have to pass the props we need one by one
                      {
                        displayToggles: ctx.displayToggles,
                        featureProp: ctx.featureProp,
                        featurePropMin: ctx.featurePropMin,
                        featurePropMax: ctx.featurePropMax,
                        featurePropPalette: ctx.featurePropPalette,
                        featurePropPaletteFlip: ctx.featurePropPaletteFlip,
                        featurePropValueCounts: ctx.featurePropValueCounts,
                        colorHelpers: ctx.colorHelpers
                      },
                      ctx.value
                    ));
			},

			m(target, anchor) {
				insert(target, span, anchor);
			},

			p(changed, ctx) {
				if (changed.displayToggles || changed.featureProp || changed.featurePropMin || changed.featurePropMax || changed.featurePropPalette || changed.featurePropPaletteFlip || changed.featurePropValueCounts || changed.colorHelpers || changed.sortedFeaturePropValueCounts) {
					setStyle(span, "background-color", formatFeaturePropValueColor(
                      // NOTE: seems there's no way to pass the whole svelte state here,
                      // so we have to pass the props we need one by one
                      {
                        displayToggles: ctx.displayToggles,
                        featureProp: ctx.featureProp,
                        featurePropMin: ctx.featurePropMin,
                        featurePropMax: ctx.featurePropMax,
                        featurePropPalette: ctx.featurePropPalette,
                        featurePropPaletteFlip: ctx.featurePropPaletteFlip,
                        featurePropValueCounts: ctx.featurePropValueCounts,
                        colorHelpers: ctx.colorHelpers
                      },
                      ctx.value
                    ));
				}
			},

			d(detach) {
				if (detach) {
					detachNode(span);
				}
			}
		};
	}

	// (123:10) {#each sortedFeaturePropValueCounts as [value, count]}
	function create_each_block_1(component, ctx) {
		var tr, td0, text0_value = ctx.count, text0, text1, td1, text2, td2, text3_value = maybeStringifyObject(ctx.value), text3;

		var if_block = (showFeaturePropColorSwatch(ctx.displayToggles.colors)) && create_if_block_7(component, ctx);

		return {
			c() {
				tr = createElement("tr");
				td0 = createElement("td");
				text0 = createText(text0_value);
				text1 = createText("\n              ");
				td1 = createElement("td");
				if (if_block) if_block.c();
				text2 = createText("\n              ");
				td2 = createElement("td");
				text3 = createText(text3_value);
				setStyle(td0, "width", "15px");
				setStyle(td0, "text-align", "right");
				setStyle(td1, "width", "15px");
			},

			m(target, anchor) {
				insert(target, tr, anchor);
				append(tr, td0);
				append(td0, text0);
				append(tr, text1);
				append(tr, td1);
				if (if_block) if_block.m(td1, null);
				append(tr, text2);
				append(tr, td2);
				append(td2, text3);
			},

			p(changed, ctx) {
				if ((changed.sortedFeaturePropValueCounts) && text0_value !== (text0_value = ctx.count)) {
					setData(text0, text0_value);
				}

				if (showFeaturePropColorSwatch(ctx.displayToggles.colors)) {
					if (if_block) {
						if_block.p(changed, ctx);
					} else {
						if_block = create_if_block_7(component, ctx);
						if_block.c();
						if_block.m(td1, null);
					}
				} else if (if_block) {
					if_block.d(1);
					if_block = null;
				}

				if ((changed.sortedFeaturePropValueCounts) && text3_value !== (text3_value = maybeStringifyObject(ctx.value))) {
					setData(text3, text3_value);
				}
			},

			d(detach) {
				if (detach) {
					detachNode(tr);
				}

				if (if_block) if_block.d();
			}
		};
	}

	// (160:6) {#if numFeaturesInViewport}
	function create_if_block_5(component, ctx) {
		var tr, td0, td1, text_1;

		return {
			c() {
				tr = createElement("tr");
				td0 = createElement("td");
				td0.textContent = "features in viewport";
				td1 = createElement("td");
				text_1 = createText(ctx.numFeaturesInViewport);
			},

			m(target, anchor) {
				insert(target, tr, anchor);
				append(tr, td0);
				append(tr, td1);
				append(td1, text_1);
			},

			p(changed, ctx) {
				if (changed.numFeaturesInViewport) {
					setData(text_1, ctx.numFeaturesInViewport);
				}
			},

			d(detach) {
				if (detach) {
					detachNode(tr);
				}
			}
		};
	}

	// (163:6) {#if numFeatureTagsInViewport != null}
	function create_if_block_4(component, ctx) {
		var tr, td0, td1, text_1;

		return {
			c() {
				tr = createElement("tr");
				td0 = createElement("td");
				td0.textContent = "feature tags in viewport";
				td1 = createElement("td");
				text_1 = createText(ctx.numFeatureTagsInViewport);
			},

			m(target, anchor) {
				insert(target, tr, anchor);
				append(tr, td0);
				append(tr, td1);
				append(td1, text_1);
			},

			p(changed, ctx) {
				if (changed.numFeatureTagsInViewport) {
					setData(text_1, ctx.numFeatureTagsInViewport);
				}
			},

			d(detach) {
				if (detach) {
					detachNode(tr);
				}
			}
		};
	}

	// (173:6) {:else}
	function create_else_block_2(component, ctx) {
		var i;

		return {
			c() {
				i = createElement("i");
				i.innerHTML = `no tags filtered<br><br>`;
			},

			m(target, anchor) {
				insert(target, i, anchor);
			},

			p: noop,

			d(detach) {
				if (detach) {
					detachNode(i);
				}
			}
		};
	}

	// (171:6) {#if tagFilterList.length > 0}
	function create_if_block_3(component, ctx) {
		var text_value = ctx.tagFilterList.join(', '), text;

		return {
			c() {
				text = createText(text_value);
			},

			m(target, anchor) {
				insert(target, text, anchor);
			},

			p(changed, ctx) {
				if ((changed.tagFilterList) && text_value !== (text_value = ctx.tagFilterList.join(', '))) {
					setData(text, text_value);
				}
			},

			d(detach) {
				if (detach) {
					detachNode(text);
				}
			}
		};
	}

	// (187:6) {:else}
	function create_else_block_1(component, ctx) {
		var text;

		return {
			c() {
				text = createText("[only show tags in view]");
			},

			m(target, anchor) {
				insert(target, text, anchor);
			},

			d(detach) {
				if (detach) {
					detachNode(text);
				}
			}
		};
	}

	// (185:6) {#if tagFilterViewport}
	function create_if_block_2(component, ctx) {
		var text;

		return {
			c() {
				text = createText("[show all tags seen]");
			},

			m(target, anchor) {
				insert(target, text, anchor);
			},

			d(detach) {
				if (detach) {
					detachNode(text);
				}
			}
		};
	}

	// (194:6) {:else}
	function create_else_block(component, ctx) {
		var text;

		return {
			c() {
				text = createText("[only show @ tags]");
			},

			m(target, anchor) {
				insert(target, text, anchor);
			},

			d(detach) {
				if (detach) {
					detachNode(text);
				}
			}
		};
	}

	// (192:6) {#if tagFilterAt}
	function create_if_block_1(component, ctx) {
		var text;

		return {
			c() {
				text = createText("[show all tag names]");
			},

			m(target, anchor) {
				insert(target, text, anchor);
			},

			d(detach) {
				if (detach) {
					detachNode(text);
				}
			}
		};
	}

	// (210:6) {#each tagDisplayList.slice(0, 500) as tag (JSON.stringify(tag))}
	function create_each_block(component, key_1, ctx) {
		var label, input, input_value_value, text0, text1_value = ctx.tag[1], text1, text2, text3_value = ctx.tag[0], text3, text4, br;

		function input_change_handler() {
			component.set({ tagFilterList: getBindingGroupValue(component._bindingGroups[1]) });
		}

		return {
			key: key_1,

			first: null,

			c() {
				label = createElement("label");
				input = createElement("input");
				text0 = createText("\n          (");
				text1 = createText(text1_value);
				text2 = createText("x) ");
				text3 = createText(text3_value);
				text4 = createText("\n        ");
				br = createElement("br");
				component._bindingGroups[1].push(input);
				addListener(input, "change", input_change_handler);
				setAttribute(input, "type", "checkbox");
				input.__value = input_value_value = ctx.tag[0];
				input.value = input.__value;
				this.first = label;
			},

			m(target, anchor) {
				insert(target, label, anchor);
				append(label, input);

				input.checked = ~ctx.tagFilterList.indexOf(input.__value);

				append(label, text0);
				append(label, text1);
				append(label, text2);
				append(label, text3);
				insert(target, text4, anchor);
				insert(target, br, anchor);
			},

			p(changed, ctx) {
				if (changed.tagFilterList) input.checked = ~ctx.tagFilterList.indexOf(input.__value);
				if ((changed.tagDisplayList) && input_value_value !== (input_value_value = ctx.tag[0])) {
					input.__value = input_value_value;
				}

				input.value = input.__value;
				if ((changed.tagDisplayList) && text1_value !== (text1_value = ctx.tag[1])) {
					setData(text1, text1_value);
				}

				if ((changed.tagDisplayList) && text3_value !== (text3_value = ctx.tag[0])) {
					setData(text3, text3_value);
				}
			},

			d(detach) {
				if (detach) {
					detachNode(label);
				}

				component._bindingGroups[1].splice(component._bindingGroups[1].indexOf(input), 1);
				removeListener(input, "change", input_change_handler);
				if (detach) {
					detachNode(text4);
					detachNode(br);
				}
			}
		};
	}

	// (218:6) {#if tagDisplayList.length > 500}
	function create_if_block(component, ctx) {
		var i, text0, text1_value = ctx.tagDisplayList.length, text1, text2;

		return {
			c() {
				i = createElement("i");
				text0 = createText("Displaying the top 500 tags of ");
				text1 = createText(text1_value);
				text2 = createText(" total");
			},

			m(target, anchor) {
				insert(target, i, anchor);
				append(i, text0);
				append(i, text1);
				append(i, text2);
			},

			p(changed, ctx) {
				if ((changed.tagDisplayList) && text1_value !== (text1_value = ctx.tagDisplayList.length)) {
					setData(text1, text1_value);
				}
			},

			d(detach) {
				if (detach) {
					detachNode(i);
				}
			}
		};
	}

	function AppUI(options) {
		init(this, options);
		this._state = assign(assign({ Object : Object, JSON : JSON }, data()), options.data);

		this._recompute({ basemap: 1, feature: 1, featurePropPaletteName: 1, featurePropValueCounts: 1, featurePropValueSort: 1, tagSort: 1, tagsWithCountsInViewport: 1, tagFilterList: 1, tagFilterViewport: 1, tagFilterAt: 1, tagFilterSearch: 1, uniqueTagsSeen: 1, tagFilterAndOr: 1, spaceId: 1, token: 1, displayToggles: 1, featureProp: 1, featurePropPaletteFlip: 1, tagFilterQueryParam: 1 }, this._state);
		this._bindingGroups = [[], []];
		this._intro = true;

		this._handlers.state = [onstate];

		if (!document.getElementById("svelte-3lp2tt-style")) add_css();

		onstate.call(this, { changed: assignTrue({}, this._state), current: this._state });

		this._fragment = create_main_fragment(this, this._state);

		this.root._oncreate.push(() => {
			this.fire("update", { changed: assignTrue({}, this._state), current: this._state });
		});

		if (options.target) {
			this._fragment.c();
			this._mount(options.target, options.anchor);

			flush(this);
		}
	}

	assign(AppUI.prototype, {
	 	destroy: destroy,
	 	get: get,
	 	fire: fire,
	 	on: on,
	 	set: set,
	 	_set: _set,
	 	_stage: _stage,
	 	_mount: _mount,
	 	_differs: _differs
	 });
	assign(AppUI.prototype, methods);

	AppUI.prototype._recompute = function _recompute(changed, state) {
		if (changed.basemap) {
			if (this._differs(state.basemapScene, (state.basemapScene = basemapScene(state)))) changed.basemapScene = true;
		}

		if (changed.feature) {
			if (this._differs(state.featurePropRows, (state.featurePropRows = featurePropRows(state)))) changed.featurePropRows = true;
		}

		if (changed.featurePropPaletteName) {
			if (this._differs(state.featurePropPalette, (state.featurePropPalette = featurePropPalette(state)))) changed.featurePropPalette = true;
		}

		if (changed.featurePropValueCounts || changed.featurePropValueSort) {
			if (this._differs(state.sortedFeaturePropValueCounts, (state.sortedFeaturePropValueCounts = sortedFeaturePropValueCounts(state)))) changed.sortedFeaturePropValueCounts = true;
		}

		if (changed.featurePropValueCounts) {
			if (this._differs(state.featurePropValueCountHash, (state.featurePropValueCountHash = featurePropValueCountHash(state)))) changed.featurePropValueCountHash = true;
		}

		if (changed.featurePropValueSort) {
			if (this._differs(state.nextFeaturePropValueSort, (state.nextFeaturePropValueSort = nextFeaturePropValueSort(state)))) changed.nextFeaturePropValueSort = true;
		}

		if (changed.tagSort) {
			if (this._differs(state.nextTagSort, (state.nextTagSort = nextTagSort(state)))) changed.nextTagSort = true;
		}

		if (changed.tagsWithCountsInViewport) {
			if (this._differs(state.uniqueTagsInViewport, (state.uniqueTagsInViewport = uniqueTagsInViewport(state)))) changed.uniqueTagsInViewport = true;
			if (this._differs(state.numFeatureTagsInViewport, (state.numFeatureTagsInViewport = numFeatureTagsInViewport(state)))) changed.numFeatureTagsInViewport = true;
		}

		if (changed.tagsWithCountsInViewport || changed.tagSort || changed.tagFilterList || changed.tagFilterViewport || changed.tagFilterAt || changed.tagFilterSearch || changed.uniqueTagsSeen) {
			if (this._differs(state.tagDisplayList, (state.tagDisplayList = tagDisplayList(state)))) changed.tagDisplayList = true;
		}

		if (changed.tagFilterList || changed.tagFilterAndOr) {
			if (this._differs(state.tagFilterQueryParam, (state.tagFilterQueryParam = tagFilterQueryParam(state)))) changed.tagFilterQueryParam = true;
		}

		if (changed.spaceId || changed.token || changed.basemap || changed.displayToggles || changed.featureProp || changed.featurePropPaletteName || changed.featurePropPaletteFlip || changed.tagFilterQueryParam) {
			if (this._differs(state.queryParams, (state.queryParams = queryParams(state)))) changed.queryParams = true;
		}
	}

	function createElement(name) {
		return document.createElement(name);
	}

	function append(target, node) {
		target.appendChild(node);
	}

	function blankObject() {
		return Object.create(null);
	}

	function createText(data) {
		return document.createTextNode(data);
	}

	function addListener(node, event, handler, options) {
		node.addEventListener(event, handler, options);
	}

	function setStyle(node, key, value) {
		node.style.setProperty(key, value);
	}

	function setAttribute(node, attribute, value) {
		if (value == null) node.removeAttribute(attribute);
		else node.setAttribute(attribute, value);
	}

	function insert(target, node, anchor) {
		target.insertBefore(node, anchor);
	}

	function setData(text, data) {
		text.data = '' + data;
	}

	function updateKeyedEach(old_blocks, component, changed, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, intro_method, next, get_context) {
		var o = old_blocks.length;
		var n = list.length;

		var i = o;
		var old_indexes = {};
		while (i--) old_indexes[old_blocks[i].key] = i;

		var new_blocks = [];
		var new_lookup = {};
		var deltas = {};

		var i = n;
		while (i--) {
			var child_ctx = get_context(ctx, list, i);
			var key = get_key(child_ctx);
			var block = lookup[key];

			if (!block) {
				block = create_each_block(component, key, child_ctx);
				block.c();
			} else if (dynamic) {
				block.p(changed, child_ctx);
			}

			new_blocks[i] = new_lookup[key] = block;

			if (key in old_indexes) deltas[key] = Math.abs(i - old_indexes[key]);
		}

		var will_move = {};
		var did_move = {};

		function insert(block) {
			block[intro_method](node, next);
			lookup[block.key] = block;
			next = block.first;
			n--;
		}

		while (o && n) {
			var new_block = new_blocks[n - 1];
			var old_block = old_blocks[o - 1];
			var new_key = new_block.key;
			var old_key = old_block.key;

			if (new_block === old_block) {
				// do nothing
				next = new_block.first;
				o--;
				n--;
			}

			else if (!new_lookup[old_key]) {
				// remove old block
				destroy(old_block, lookup);
				o--;
			}

			else if (!lookup[new_key] || will_move[new_key]) {
				insert(new_block);
			}

			else if (did_move[old_key]) {
				o--;

			} else if (deltas[new_key] > deltas[old_key]) {
				did_move[new_key] = true;
				insert(new_block);

			} else {
				will_move[old_key] = true;
				o--;
			}
		}

		while (o--) {
			var old_block = old_blocks[o];
			if (!new_lookup[old_block.key]) destroy(old_block, lookup);
		}

		while (n) insert(new_blocks[n - 1]);

		return new_blocks;
	}

	function destroyBlock(block, lookup) {
		block.d(1);
		lookup[block.key] = null;
	}

	function detachNode(node) {
		node.parentNode.removeChild(node);
	}

	function removeListener(node, event, handler, options) {
		node.removeEventListener(event, handler, options);
	}

	function noop() {}

	function destroyEach(iterations, detach) {
		for (var i = 0; i < iterations.length; i += 1) {
			if (iterations[i]) iterations[i].d(detach);
		}
	}

	function toggleClass(element, name, toggle) {
		element.classList[toggle ? 'add' : 'remove'](name);
	}

	function selectValue(select) {
		var selectedOption = select.querySelector(':checked') || select.options[0];
		return selectedOption && selectedOption.__value;
	}

	function selectOption(select, value) {
		for (var i = 0; i < select.options.length; i += 1) {
			var option = select.options[i];

			if (option.__value === value) {
				option.selected = true;
				return;
			}
		}
	}

	function getBindingGroupValue(group) {
		var value = [];
		for (var i = 0; i < group.length; i += 1) {
			if (group[i].checked) value.push(group[i].__value);
		}
		return value;
	}

	function init(component, options) {
		component._handlers = blankObject();
		component._slots = blankObject();
		component._bind = options._bind;
		component._staged = {};

		component.options = options;
		component.root = options.root || component;
		component.store = options.store || component.root.store;

		if (!options.root) {
			component._beforecreate = [];
			component._oncreate = [];
			component._aftercreate = [];
		}
	}

	function assign(tar, src) {
		for (var k in src) tar[k] = src[k];
		return tar;
	}

	function assignTrue(tar, src) {
		for (var k in src) tar[k] = 1;
		return tar;
	}

	function flush(component) {
		component._lock = true;
		callAll(component._beforecreate);
		callAll(component._oncreate);
		callAll(component._aftercreate);
		component._lock = false;
	}

	function destroy(detach) {
		this.destroy = noop;
		this.fire('destroy');
		this.set = noop;

		this._fragment.d(detach !== false);
		this._fragment = null;
		this._state = {};
	}

	function get() {
		return this._state;
	}

	function fire(eventName, data) {
		var handlers =
			eventName in this._handlers && this._handlers[eventName].slice();
		if (!handlers) return;

		for (var i = 0; i < handlers.length; i += 1) {
			var handler = handlers[i];

			if (!handler.__calling) {
				try {
					handler.__calling = true;
					handler.call(this, data);
				} finally {
					handler.__calling = false;
				}
			}
		}
	}

	function on(eventName, handler) {
		var handlers = this._handlers[eventName] || (this._handlers[eventName] = []);
		handlers.push(handler);

		return {
			cancel: function() {
				var index = handlers.indexOf(handler);
				if (~index) handlers.splice(index, 1);
			}
		};
	}

	function set(newState) {
		this._set(assign({}, newState));
		if (this.root._lock) return;
		flush(this.root);
	}

	function _set(newState) {
		var oldState = this._state,
			changed = {},
			dirty = false;

		newState = assign(this._staged, newState);
		this._staged = {};

		for (var key in newState) {
			if (this._differs(newState[key], oldState[key])) changed[key] = dirty = true;
		}
		if (!dirty) return;

		this._state = assign(assign({}, oldState), newState);
		this._recompute(changed, this._state);
		if (this._bind) this._bind(changed, this._state);

		if (this._fragment) {
			this.fire("state", { changed: changed, current: this._state, previous: oldState });
			this._fragment.p(changed, this._state);
			this.fire("update", { changed: changed, current: this._state, previous: oldState });
		}
	}

	function _stage(newState) {
		assign(this._staged, newState);
	}

	function _mount(target, anchor) {
		this._fragment[this._fragment.i ? 'i' : 'm'](target, anchor || null);
	}

	function _differs(a, b) {
		return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
	}

	function callAll(fns) {
		while (fns && fns.length) fns.shift()();
	}

	return AppUI;

})));